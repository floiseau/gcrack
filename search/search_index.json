{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":""},{"location":"#description","title":"Description","text":"<p><code>gcrack</code> is a 2D finite element solver for simulating crack propagation using Linear Elastic Fracture Mechanics. It is built on top of <code>fenicsx</code>.</p> <p>It has several non-classic features :</p> <ul> <li>crack propagation in anistropic media,</li> <li>indirect load control using path-following methods.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To run <code>gcrack</code>, install the required Python modules in a dedicated environment:</p> <ol> <li> <p>Create and activate a new conda environment:</p> <pre><code>conda create -n gcrack\nconda activate gcrack\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>conda install -c conda-forge numpy sympy mpich python-gmsh fenics-dolfinx pyvista jax jaxlib=*=*cpu*\n</code></pre> </li> <li> <p>Install gcrack:</p> <pre><code>pip install .       # If you cloned the repo\npip install gcrack  # If you want to install from pypi\n</code></pre> </li> </ol>"},{"location":"#hands-on-test-with-examples","title":"Hands-On: Test with Examples","text":"<p>The <code>examples</code> directory contains ready-to-run scripts. Just follow these steps:</p> <ol> <li> <p>Navigate to the <code>examples</code> directory.</p> <pre><code>cd gcrack/examples/example_name\n</code></pre> </li> <li> <p>Activate the conda environment:</p> <pre><code>conda activate gcrack\n</code></pre> </li> <li> <p>Run the provided <code>run.py</code> script using the provided <code>makefile</code>:</p> <pre><code>make simulation\n</code></pre> </li> <li> <p>Vizualize the results in the directory <code>results_YYY-MM-DD-HH-mm-ss/</code>.</p> </li> </ol>"},{"location":"#usage","title":"Usage","text":""},{"location":"#requirements","title":"Requirements","text":"<p>To run a simulation, the only required file is a Python script (named <code>run.py</code> in the examples). It contains the definition of a class inheriting from <code>GCrackBase</code>. In this class, the methods to define the mesh (<code>generate_mesh</code>), to define the boundary conditions (e.g., <code>define_controlled_displacements</code>), and define the critical energy release rate (<code>Gc</code>) must be defined.</p>"},{"location":"#running-the-solver","title":"Running the Solver","text":"<p>Once the Python script is define, one only need to call the method <code>GCrackBase.run</code> to start the resolution.</p> <ol> <li> <p>Activate the <code>gcrack</code> environment:</p> <pre><code>conda activate gcrack\n</code></pre> </li> <li> <p>Run the solver:</p> <pre><code>python run.py\n</code></pre> </li> </ol> <p>Notes</p> <ul> <li> <p>On some Linux distributions, set <code>OMP_NUM_THREADS=1</code> to prevent FEniCSx from using all available threads:</p> <pre><code>OMP_NUM_THREADS=1 python run.py\n</code></pre> </li> </ul>"},{"location":"#outputs","title":"Outputs","text":"<p>Results are saved in the <code>results</code> subdirectory. Two types of file are exported:</p> <ul> <li>The displacement fields are saved in <code>VTK</code> files (with the extension <code>.pvd</code>).</li> <li>The scalar outputs (displacement/force measures, stress intensity factors, etc.) are saved in the <code>results.csv</code> CSV file.</li> </ul> <p>Vizualization</p> <p>To open the <code>VTK</code> files, vizualization tools such as Paraview or pyvsita can be employed.</p>"},{"location":"API/LEFM/","title":"LEFM","text":"<p>Module for computing stress intensity factor (SIF) influence functions and energy release rates.</p> <p>This module provides functions to compute the functions F_ij and G_i as described in Amestoy and Leblond (1992). These functions are used to calculate the SIFs at the tip of an infinitesimal straight crack extension with a given bifurcation angle.</p> References <p>Amestoy, M., &amp; Leblond, J. B. (1992). Crack paths in plane situations\u2014II. Detailed form of the expansion of the stress intensity factors. International Journal of Solids and Structures, 29(4), 465\u2013501. https://doi.org/10.1016/0020-7683(92)90210-K</p>"},{"location":"API/LEFM/#gcrack.lefm.F11","title":"<code>F11(m)</code>","text":"<p>Computes F11 function for a given normalized crack angle.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Normalized crack angle, defined as (phi - phi0) / pi.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the F11 for the given normalized crack angle.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef F11(m: float) -&gt; float:\n    \"\"\"Computes F11 function for a given normalized crack angle.\n\n    Args:\n        m (float): Normalized crack angle, defined as (phi - phi0) / pi.\n\n    Returns:\n        float: The value of the F11 for the given normalized crack angle.\n    \"\"\"\n    return (\n        1\n        - 3 * pi**2 / 8 * m**2\n        + (pi**2 - 5 * pi**4 / 128) * m**4\n        + (pi**2 / 9 - 11 * pi**4 / 72 + 119 * pi**6 / 15_360) * m**6\n        + 5.07790 * m**8\n        - 2.88312 * m**10\n        - 0.0925 * m**12\n        + 2.996 * m**14\n        - 4.059 * m**16\n        + 1.63 * m**18\n        + 4.1 * m**20\n    )\n</code></pre>"},{"location":"API/LEFM/#gcrack.lefm.F12","title":"<code>F12(m)</code>","text":"<p>Computes F12 function for a given normalized crack angle.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Normalized crack angle, defined as (phi - phi0) / pi.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the F12 for the given normalized crack angle.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef F12(m: float) -&gt; float:\n    \"\"\"Computes F12 function for a given normalized crack angle.\n\n    Args:\n        m (float): Normalized crack angle, defined as (phi - phi0) / pi.\n\n    Returns:\n        float: The value of the F12 for the given normalized crack angle.\n    \"\"\"\n    return (\n        -3 * pi / 2 * m\n        + (10 * pi / 3 + pi**3 / 16) * m**3\n        + (-2 * pi - 133 * pi**3 / 180 + 59 * pi**5 / 1280) * m**5\n        + 12.313906 * m**7\n        - 7.32433 * m**9\n        + 1.5793 * m**11\n        + 4.0216 * m**13\n        - 6.915 * m**15\n        + 4.21 * m**17\n        + 4.56 * m**19\n    )\n</code></pre>"},{"location":"API/LEFM/#gcrack.lefm.F21","title":"<code>F21(m)</code>","text":"<p>Computes F21 function for a given normalized crack angle.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Normalized crack angle, defined as (phi - phi0) / pi.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the F21 for the given normalized crack angle.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef F21(m: float) -&gt; float:\n    \"\"\"Computes F21 function for a given normalized crack angle.\n\n    Args:\n        m (float): Normalized crack angle, defined as (phi - phi0) / pi.\n\n    Returns:\n        float: The value of the F21 for the given normalized crack angle.\n    \"\"\"\n    return (\n        pi / 2 * m\n        - (4 * pi / 3 + pi**3 / 48) * m**3\n        + (-2 * pi / 3 + 13 * pi**3 / 30 - 59 * pi**5 / 3840) * m**5\n        - 6.176023 * m**7\n        + 4.44112 * m**9\n        - 1.5340 * m**11\n        - 2.0700 * m**13\n        + 4.684 * m**15\n        - 3.95 * m**17\n        - 1.32 * m**19\n    )\n</code></pre>"},{"location":"API/LEFM/#gcrack.lefm.F22","title":"<code>F22(m)</code>","text":"<p>Computes F22 function for a given normalized crack angle.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Normalized crack angle, defined as (phi - phi0) / pi.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the F22 for the given normalized crack angle.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef F22(m: float) -&gt; float:\n    \"\"\"Computes F22 function for a given normalized crack angle.\n\n    Args:\n        m (float): Normalized crack angle, defined as (phi - phi0) / pi.\n\n    Returns:\n        float: The value of the F22 for the given normalized crack angle.\n    \"\"\"\n    return (\n        1\n        - (4 + 3 / 8 * pi**2) * m**2\n        + (8 / 3 + 29 / 18 * pi**2 - 5 / 128 * pi**4) * m**4\n        + (-32 / 15 - 4 / 9 * pi**2 - 1159 / 7200 * pi**4 + 119 / 15_360 * pi**6) * m**6\n        + 10.58254 * m**8\n        - 4.78511 * m**10\n        - 1.8804 * m**12\n        + 7.280 * m**14\n        - 7.591 * m**16\n        + 0.25 * m**18\n        + 12.5 * m**20\n    )\n</code></pre>"},{"location":"API/LEFM/#gcrack.lefm.Fmat","title":"<code>Fmat(m)</code>","text":"<p>Construct the matrix F containing the Fij functions of Amestoy-Leblond.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Normalized crack angle, defined as (phi - phi0) / pi.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: The 2x2 matrix F for the given normalized crack angle.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef Fmat(m: float) -&gt; jnp.ndarray:\n    \"\"\"Construct the matrix F containing the Fij functions of Amestoy-Leblond.\n\n    Args:\n        m (float): Normalized crack angle, defined as (phi - phi0) / pi.\n\n    Returns:\n        jnp.ndarray: The 2x2 matrix F for the given normalized crack angle.\n    \"\"\"\n    return jnp.array([[F11(m), F12(m)], [F21(m), F22(m)]])\n</code></pre>"},{"location":"API/LEFM/#gcrack.lefm.G1","title":"<code>G1(m)</code>","text":"<p>Computes G1 function for a given normalized crack angle.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Normalized crack angle, defined as (phi - phi0) / pi.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the G1 for the given normalized crack angle.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef G1(m: float) -&gt; float:\n    \"\"\"Computes G1 function for a given normalized crack angle.\n\n    Args:\n        m (float): Normalized crack angle, defined as (phi - phi0) / pi.\n\n    Returns:\n        float: The value of the G1 for the given normalized crack angle.\n    \"\"\"\n    return (\n        (2 * pi) ** (3 / 2) * m**2\n        - 47.933390 * m**4\n        + 63.665987 * m**6\n        - 50.70880 * m**8\n        + 26.66807 * m**10\n        - 6.0205 * m**12\n        - 7.314 * m**14\n        + 10.947 * m**16\n        - 2.85 * m**18\n        - 13.7 * m**20\n    )\n</code></pre>"},{"location":"API/LEFM/#gcrack.lefm.G2","title":"<code>G2(m)</code>","text":"<p>Computes G2 function for a given normalized crack angle.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Normalized crack angle, defined as (phi - phi0) / pi.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the G2 for the given normalized crack angle.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef G2(m: float) -&gt; float:\n    \"\"\"Computes G2 function for a given normalized crack angle.\n\n    Args:\n        m (float): Normalized crack angle, defined as (phi - phi0) / pi.\n\n    Returns:\n        float: The value of the G2 for the given normalized crack angle.\n    \"\"\"\n    return (\n        -2 * jnp.sqrt(2 * pi) * m\n        + 12 * jnp.sqrt(2 * pi) * m**3\n        - 59.565733 * m**5\n        + 61.174444 * m**7\n        - 39.90249 * m**9\n        + 15.6222 * m**11\n        + 3.0343 * m**13\n        - 12.781 * m**15\n        + 9.69 * m**17\n        + 6.62 * m**19\n    )\n</code></pre>"},{"location":"API/LEFM/#gcrack.lefm.G_star","title":"<code>G_star(phi, phi0, KI, KII, T, Ep, s)</code>","text":"<p>Computes the energy release rate G* after a infinitesimal kink of angle.</p> <p>This function computes the energy release rate G* using the Irwin formula. The SIFs are calculated as described in Amestoy and Leblond (1992).</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>Current crack angle.</p> required <code>phi0</code> <code>float</code> <p>Initial crack angle.</p> required <code>KI</code> <code>float</code> <p>Mode I stress intensity factor.</p> required <code>KII</code> <code>float</code> <p>Mode II stress intensity factor.</p> required <code>T</code> <code>float</code> <p>T-stress.</p> required <code>Ep</code> <code>float</code> <p>Plane strain/stress modulus.</p> required <code>s</code> <code>float</code> <p>Internal length associated with T-stress.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The energy release rate G* for the given crack angle and stress intensity factors.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef G_star(\n    phi: float, phi0: float, KI: float, KII: float, T: float, Ep: float, s: float\n) -&gt; float:\n    \"\"\"Computes the energy release rate G* after a infinitesimal kink of angle.\n\n    This function computes the energy release rate G* using the Irwin formula.\n    The SIFs are calculated as described in Amestoy and Leblond (1992).\n\n    Args:\n        phi (float): Current crack angle.\n        phi0 (float): Initial crack angle.\n        KI (float): Mode I stress intensity factor.\n        KII (float): Mode II stress intensity factor.\n        T (float): T-stress.\n        Ep (float): Plane strain/stress modulus.\n        s (float): Internal length associated with T-stress.\n\n    Returns:\n        float: The energy release rate G* for the given crack angle and stress intensity factors.\n    \"\"\"\n    # Store the SIFs in an array\n    k = jnp.array([KI, KII])\n    # Calculate m\n    m = (phi - phi0) / pi\n    # Compute the Amestoy-Leblond functions\n    f_mat = Fmat(m)\n    g_vec = Gvec(m)\n    # Apply Amestoy-Leblond formula\n    ks = f_mat @ k + g_vec * T * jnp.sqrt(s)\n    # Compute the G star\n    return 1 / Ep * jnp.dot(ks, ks)\n</code></pre>"},{"location":"API/LEFM/#gcrack.lefm.G_star_coupled","title":"<code>G_star_coupled(phi, phi0, KI1, KII1, T1, KI2, KII2, T2, Ep, s)</code>","text":"<p>Computes the coupled energy release rate G* for two sets of stress intensity factors.</p> <p>It is used to evaluate the energy release rate for two interacting loading conditions.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>Current crack angle.</p> required <code>phi0</code> <code>float</code> <p>Initial crack angle.</p> required <code>KI1</code> <code>float</code> <p>Mode I stress intensity factor for the first load.</p> required <code>KII1</code> <code>float</code> <p>Mode II stress intensity factor for the first load.</p> required <code>T1</code> <code>float</code> <p>T-stress for the first load.</p> required <code>KI2</code> <code>float</code> <p>Mode I stress intensity factor for the second load.</p> required <code>KII2</code> <code>float</code> <p>Mode II stress intensity factor for the second load.</p> required <code>T2</code> <code>float</code> <p>T-stress for the second load.</p> required <code>Ep</code> <code>float</code> <p>Plane strain modulus.</p> required <code>s</code> <code>float</code> <p>Internal length associated with T-stress.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The coupled energy release rate G* for the given crack angle and stress intensity factors.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef G_star_coupled(\n    phi: float,\n    phi0: float,\n    KI1: float,\n    KII1: float,\n    T1: float,\n    KI2: float,\n    KII2: float,\n    T2: float,\n    Ep: float,\n    s: float,\n) -&gt; float:\n    \"\"\"Computes the coupled energy release rate G* for two sets of stress intensity factors.\n\n    It is used to evaluate the energy release rate for two interacting loading conditions.\n\n    Args:\n        phi (float): Current crack angle.\n        phi0 (float): Initial crack angle.\n        KI1 (float): Mode I stress intensity factor for the first load.\n        KII1 (float): Mode II stress intensity factor for the first load.\n        T1 (float): T-stress for the first load.\n        KI2 (float): Mode I stress intensity factor for the second load.\n        KII2 (float): Mode II stress intensity factor for the second load.\n        T2 (float): T-stress for the second load.\n        Ep (float): Plane strain modulus.\n        s (float): Internal length associated with T-stress.\n\n    Returns:\n        float: The coupled energy release rate G* for the given crack angle and stress intensity factors.\n    \"\"\"\n    # Calculate m\n    m = (phi - phi0) / pi\n    # Compute F^T * F\n    F = Fmat(m)\n    FT_F = F.T @ F\n    # Store the SIFs in an array\n    k1 = jnp.array([KI1, KII1])\n    k2 = jnp.array([KI2, KII2])\n    # Compute the G star\n    return 2 / Ep * jnp.einsum(\"i,ij,j-&gt;\", k1, FT_F, k2)\n</code></pre>"},{"location":"API/LEFM/#gcrack.lefm.Gvec","title":"<code>Gvec(m)</code>","text":"<p>Construct the vector G containing the Gi functions of Amestoy-Leblond.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>float</code> <p>Normalized crack angle, defined as (phi - phi0) / pi.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>jnp.ndarray: The vector G for the given normalized crack angle.</p> Source code in <code>src/gcrack/lefm.py</code> <pre><code>@jit\ndef Gvec(m: float) -&gt; jnp.ndarray:\n    \"\"\"Construct the vector G containing the Gi functions of Amestoy-Leblond.\n\n    Args:\n        m (float): Normalized crack angle, defined as (phi - phi0) / pi.\n\n    Returns:\n        jnp.ndarray: The vector G for the given normalized crack angle.\n    \"\"\"\n    return jnp.array([G1(m), G2(m)])\n</code></pre>"},{"location":"API/SIF/","title":"SIF","text":"<p>Module for computing Stress Intensity Factors (SIFs).</p> <p>This module provides functions to compute Stress Intensity Factors (SIFs) using different methods, including the I-integral method and Williams series interpolation.</p> <p>Functions:</p> Name Description <code>compute_theta_field</code> <p>Computes the theta field for contour integrals.</p> <code>compute_auxiliary_displacement_field</code> <p>Generates auxiliary displacement fields for different fracture modes.</p> <code>compute_I_integral</code> <p>Calculates the I-integral for interaction energy.</p> <code>compute_SIFs_with_I_integral</code> <p>Computes SIFs using the I-integral method.</p> <code>compute_SIFs_from_William_series_interpolation</code> <p>Computes SIFs using Williams series interpolation.</p> <code>compute_SIFs</code> <p>Dispatches to the appropriate SIF computation method based on the specified method.</p>"},{"location":"API/SIF/#gcrack.sif.compute_I_integral","title":"<code>compute_I_integral(domain, model, u, u_aux, theta)</code>","text":"<p>Computes the I-integral.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain object representing the physical space.</p> required <code>model</code> <code>ElasticModel</code> <p>The elastic model defining the material properties.</p> required <code>u</code> <code>Function</code> <p>The displacement field from the finite element solution.</p> required <code>u_aux</code> <code>Expr</code> <p>The auxiliary displacement field.</p> required <code>theta</code> <code>Expr</code> <p>The theta field for the contour integral.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the I-integral.</p> Source code in <code>src/gcrack/sif.py</code> <pre><code>def compute_I_integral(\n    domain: Domain,\n    model: ElasticModel,\n    u: fem.Function,\n    u_aux: ufl.core.expr.Expr,\n    theta: ufl.core.expr.Expr,\n) -&gt; float:\n    \"\"\"Computes the I-integral.\n\n    Args:\n        domain (Domain): The domain object representing the physical space.\n        model (ElasticModel): The elastic model defining the material properties.\n        u (fem.Function): The displacement field from the finite element solution.\n        u_aux (ufl.core.expr.Expr): The auxiliary displacement field.\n        theta (ufl.core.expr.Expr): The theta field for the contour integral.\n\n    Returns:\n        float: The value of the I-integral.\n    \"\"\"\n    # Compute the gradients\n    grad_u = model.grad_u(u)\n    gua_2D = ufl.grad(u_aux)\n    # Compute theta gradient and div\n    div_theta = ufl.div(theta)\n    gt_2D = ufl.grad(theta)\n    # Convert the 2D gradient to 3D\n    grad_u_aux = ufl.as_tensor(\n        [\n            [gua_2D[0, 0], gua_2D[0, 1], 0],\n            [gua_2D[1, 0], gua_2D[1, 1], 0],\n            [gua_2D[2, 0], gua_2D[2, 1], 0],\n        ]\n    )\n    grad_theta = ufl.as_tensor(\n        [\n            [gt_2D[0, 0], gt_2D[0, 1], 0],\n            [gt_2D[1, 0], gt_2D[1, 1], 0],\n            [0, 0, 0],\n        ]\n    )\n    # Compute the strains\n    eps = model.eps(u)\n    eps_aux = ufl.sym(grad_u_aux)\n    # Compute the stresses\n    sig = model.sig(u)\n    sig_aux = model.la * ufl.tr(eps_aux) * ufl.Identity(3) + 2 * model.mu * eps_aux\n    # Compute the interaction integral (reduce the quadrature degree for faster evaluation)\n    dx = ufl.Measure(\"dx\", domain=domain.mesh, metadata={\"quadrature_degree\": 4})\n    I_expr = (\n        ufl.inner(sig, grad_u_aux * grad_theta)\n        + ufl.inner(sig_aux, grad_u * grad_theta)\n        - 1.0 / 2.0 * ufl.inner(sig, eps_aux) * div_theta\n        - 1.0 / 2.0 * ufl.inner(sig_aux, eps) * div_theta\n    ) * dx\n    I_integral = fem.assemble_scalar(fem.form(I_expr))\n    return I_integral\n</code></pre>"},{"location":"API/SIF/#gcrack.sif.compute_SIFs","title":"<code>compute_SIFs(domain, model, u, xc, phi0, R_int, R_ext, method)</code>","text":"<p>Computes the Stress Intensity Factors (SIFs) for a given elastic model and displacement field.</p> <p>This function serves as a dispatcher to compute SIFs using the specified method. Supported methods include the I-integral method and Williams series interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain object representing the physical space.</p> required <code>model</code> <code>ElasticModel</code> <p>The elastic model defining the material properties.</p> required <code>u</code> <code>Function</code> <p>The displacement field from the finite element solution.</p> required <code>xc</code> <code>ndarray</code> <p>Coordinates of the crack tip.</p> required <code>phi0</code> <code>float</code> <p>Angle defining the crack orientation.</p> required <code>R_int</code> <code>float</code> <p>Internal radius of the pacman region.</p> required <code>R_ext</code> <code>float</code> <p>External radius of the pacman region.</p> required <code>method</code> <code>str</code> <p>The method used for calculating the SIFs. Supported methods are:</p> <ul> <li>\"i-integral\": Uses the I-integral method.</li> <li>\"williams\": Uses Williams series interpolation.</li> </ul> required <p>Returns:</p> Name Type Description <code>sif</code> <code>dict</code> <p>A dictionary containing the computed Stress Intensity Factors.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the specified method is not implemented.</p> Source code in <code>src/gcrack/sif.py</code> <pre><code>def compute_SIFs(\n    domain: Domain,\n    model: ElasticModel,\n    u: fem.Function,\n    xc: np.ndarray,\n    phi0: float,\n    R_int: float,\n    R_ext: float,\n    method: str,\n) -&gt; dict:\n    \"\"\"Computes the Stress Intensity Factors (SIFs) for a given elastic model and displacement field.\n\n    This function serves as a dispatcher to compute SIFs using the specified method.\n    Supported methods include the I-integral method and Williams series interpolation.\n\n    Args:\n        domain (Domain): The domain object representing the physical space.\n        model (ElasticModel): The elastic model defining the material properties.\n        u (fem.Function): The displacement field from the finite element solution.\n        xc (np.ndarray): Coordinates of the crack tip.\n        phi0 (float): Angle defining the crack orientation.\n        R_int (float): Internal radius of the pacman region.\n        R_ext (float): External radius of the pacman region.\n        method (str): The method used for calculating the SIFs. Supported methods are:\n\n            - \"i-integral\": Uses the I-integral method.\n            - \"williams\": Uses Williams series interpolation.\n\n    Returns:\n        sif (dict): A dictionary containing the computed Stress Intensity Factors.\n\n    Raises:\n        NotImplementedError: If the specified method is not implemented.\n    \"\"\"\n    # Compute the SIFs\n    match method.lower():\n        case \"i-integral\":\n            SIFs = compute_SIFs_with_I_integral(\n                domain,\n                model,\n                u,\n                xc,\n                phi0,\n                R_int,\n                R_ext,\n            )\n        case \"williams\":\n            SIFs = compute_SIFs_from_William_series_interpolation(\n                domain,\n                model,\n                u,\n                xc,\n                phi0,\n                R_int,\n                R_ext,\n            )\n        case _:\n            raise NotImplementedError(\n                f\"SIF method '{method}' is not implemented. Existing methods are: 'I-integral' and 'Williams'.\"\n            )\n\n    # Display informations\n    for name, val in SIFs.items():\n        print(f\"\u2502  \u2502  {name: &lt;3}: {val:.3g}\")\n    print(\"\u2502  \u2502  End of SIF calculations\")\n    return SIFs\n</code></pre>"},{"location":"API/SIF/#gcrack.sif.compute_SIFs_from_William_series_interpolation","title":"<code>compute_SIFs_from_William_series_interpolation(domain, model, u, xc, phi0, R_int, R_ext)</code>","text":"<p>Computes Stress Intensity Factors (SIFs) using Williams series interpolation.</p> <p>This function calculates the SIFs by interpolating the displacement field using the Williams series expansion around the crack tip. It extracts the displacement data within a \"pacman\"-shaped region around the crack tip and performs a least-squares fit to determine the SIFs.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain object representing the physical space.</p> required <code>model</code> <code>ElasticModel</code> <p>The elastic model defining the material properties.</p> required <code>u</code> <code>Function</code> <p>The displacement field from the finite element solution.</p> required <code>xc</code> <code>ndarray</code> <p>Coordinates of the crack tip.</p> required <code>phi0</code> <code>float</code> <p>Angle defining the crack orientation.</p> required <code>R_int</code> <code>float</code> <p>Inner radius of the pacman region.</p> required <code>R_ext</code> <code>float</code> <p>Outer radius of the pacman region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the computed SIFs and Williams series coefficients.</p> Source code in <code>src/gcrack/sif.py</code> <pre><code>def compute_SIFs_from_William_series_interpolation(\n    domain: Domain,\n    model: ElasticModel,\n    u: fem.Function,\n    xc: np.ndarray,\n    phi0: float,\n    R_int: float,\n    R_ext: float,\n) -&gt; dict:\n    \"\"\"Computes Stress Intensity Factors (SIFs) using Williams series interpolation.\n\n    This function calculates the SIFs by interpolating the displacement field using the Williams series expansion around the crack tip.\n    It extracts the displacement data within a \"pacman\"-shaped region around the crack tip and performs a least-squares fit to determine the SIFs.\n\n    Args:\n        domain (Domain): The domain object representing the physical space.\n        model (ElasticModel): The elastic model defining the material properties.\n        u (fem.Function): The displacement field from the finite element solution.\n        xc (np.ndarray): Coordinates of the crack tip.\n        phi0 (float): Angle defining the crack orientation.\n        R_int (float): Inner radius of the pacman region.\n        R_ext (float): Outer radius of the pacman region.\n\n    Returns:\n        dict: A dictionary containing the computed SIFs and Williams series coefficients.\n    \"\"\"\n\n    ### Extract x and u in the pacman from the FEM results\n    def in_pacman(x):\n        xc1 = np.array(xc)\n        # Center coordinate on crack tip\n        dx = x - xc1[:, np.newaxis]\n        # Compute the distance to crack tip\n        r = np.linalg.norm(dx, axis=0)\n        # Keep the elements in the external radius\n        in_pacman = r &lt; R_ext\n        # Remove the nodes that are too close to crack line\n        xc2 = xc1 + R_ext * np.array([np.cos(np.pi + phi0), np.sin(np.pi + phi0), 0])\n        far_from_crack = distance_point_to_segment(x, xc1, xc2) &gt; R_int\n        return np.logical_and(in_pacman, far_from_crack)\n\n    # Get the entity ids\n    entities_ids = dolfinx.mesh.locate_entities(domain.mesh, 2, in_pacman)\n    # Get the dof of each element\n    dof_ids = dolfinx.mesh.entities_to_geometry(domain.mesh, 2, entities_ids)\n    # Generate the list of nodes (without any duplicated nodes)\n    dof_unique_ids = np.unique(dof_ids.flatten())\n    # Get the node coordinates (and set the crack tip as the origin)\n    xs = domain.mesh.geometry.x[dof_unique_ids] - np.array(xc)[np.newaxis, :]\n\n    # Construct the displacement vector\n    N_comp = u.function_space.value_shape[0]\n    us = np.empty((xs.shape[0], N_comp))\n    # Get the displacements\n    if model.assumption.startswith(\"plane\"):\n        # Get the displacement values\n        us[:, 0] = u.x.array[2 * dof_unique_ids]\n        us[:, 1] = u.x.array[2 * dof_unique_ids + 1]\n        # Find crack tip element\n        xs_all = domain.mesh.geometry.x - xc\n        crack_tip_id = np.argmin(np.linalg.norm(xs_all, axis=1))\n        # Remove crack tip motion\n        us[:, 0] -= u.x.array[2 * crack_tip_id]\n        us[:, 1] -= u.x.array[2 * crack_tip_id + 1]\n    elif model.assumption == \"anti_plane\":\n        # Get the displacement values\n        us[:, 0] = u.x.array[dof_unique_ids]\n\n    # Define the Williams series field\n    N_min = -1  # -3\n    N_max = 7  # 9\n\n    # Get the complex coordinates around crack tip\n    zs = xs[:, 0] + 1j * xs[:, 1]\n    zs *= np.exp(-1j * phi0)\n    # Compute the sizes\n    Nn = us.shape[0]  # Number of nodes\n    Ndof = us.shape[0] * us.shape[1]  # Number of dof\n\n    # Compute mu and kappa at crack tip (for heterogeneous cases)\n    mu = model.mu_func(xc)\n    ka = model.ka_func(xc)\n\n    # Construct the matrix Gamma\n    if model.assumption.startswith(\"plane\"):\n        xaxis = np.array([2 * n for n in range(Nn)])  # Mask to isolate x axis\n        yaxis = np.array([2 * n + 1 for n in range(Nn)])  # Mask to isolate y axis\n        # Get the displacement vector (from FEM)\n        UF = us.flatten()\n        # Get the Gamma matrix\n        Gamma = np.empty((Ndof, 2 * (N_max - N_min + 1)))\n        for i, n in enumerate(range(N_min, N_max + 1)):\n            GI = Gamma_I(n, zs, mu, ka) * np.exp(1j * phi0)\n            GII = Gamma_II(n, zs, mu, ka) * np.exp(1j * phi0)\n            Gamma[xaxis, 2 * i] = np.real(GI)\n            Gamma[yaxis, 2 * i] = np.imag(GI)\n            Gamma[xaxis, 2 * i + 1] = np.real(GII)\n            Gamma[yaxis, 2 * i + 1] = np.imag(GII)\n    elif model.assumption == \"anti_plane\":\n        # Get the displacement vector (from FEM)\n        UF = us.flatten()\n        # Get the Gamma matrix\n        Gamma = np.empty((Ndof, N_max - N_min + 1))\n        for i, n in enumerate(range(N_min, N_max + 1)):\n            GIII = Gamma_III(n, zs, mu, ka)\n            Gamma[:, i] = GIII\n    # Solve the least square problem\n    sol, res, _, _ = np.linalg.lstsq(Gamma, UF)\n    # Create the SIF dictionary\n    SIFs = {}\n    if model.assumption.startswith(\"plane\"):\n        # Extract KI, KII and T\n        SIFs[\"KI\"] = sol[2 * (1 - N_min)]\n        SIFs[\"KII\"] = sol[2 * (1 - N_min) + 1]\n        SIFs[\"KIII\"] = 0\n        # TODO: Check this scaling. It seems to be false to me\n        SIFs[\"T\"] = 2 * np.sqrt(2) / np.sqrt(np.pi) * sol[2 * (2 - N_min)]\n        # Store the other coefficients of the seriess\n        for i, n in enumerate(range(N_min, N_max + 1)):\n            SIFs[f\"aI_{n}\"] = sol[2 * i]\n            SIFs[f\"aII_{n}\"] = sol[2 * i + 1]\n    elif model.assumption == \"anti_plane\":\n        SIFs[\"KI\"] = 0\n        SIFs[\"KII\"] = 0\n        SIFs[\"KIII\"] = sol[1 - N_min] / 4\n        SIFs[\"T\"] = 0\n        # Store the other coefficients of the seriess\n        for i, n in enumerate(range(N_min, N_max + 1)):\n            SIFs[f\"aIII_{n}\"] = sol[i]\n    # Return the SIFs\n    return SIFs\n</code></pre>"},{"location":"API/SIF/#gcrack.sif.compute_SIFs_with_I_integral","title":"<code>compute_SIFs_with_I_integral(domain, model, u, xc, phi0, R_int, R_ext)</code>","text":"<p>Computes Stress Intensity Factors (SIFs) using the I-integral method.</p> <p>This function calculates the SIFs for modes I, II, III, and T-stress using the I-integral method.</p> Note <p>Line integrals are replaced with domain (surface) integrals.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain object representing the physical space.</p> required <code>model</code> <code>ElasticModel</code> <p>The elastic model defining the material properties.</p> required <code>u</code> <code>Function</code> <p>The displacement field from the finite element solution.</p> required <code>xc</code> <code>ndarray</code> <p>Coordinates of the crack tip.</p> required <code>phi0</code> <code>float</code> <p>Angle defining the crack orientation.</p> required <code>R_int</code> <code>float</code> <p>Inner radius of the theta field transition region.</p> required <code>R_ext</code> <code>float</code> <p>Outer radius of the theta field transition region.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the computed SIFs (KI, KII, KIII, T).</p> Source code in <code>src/gcrack/sif.py</code> <pre><code>def compute_SIFs_with_I_integral(\n    domain: Domain,\n    model: ElasticModel,\n    u: fem.Function,\n    xc: np.ndarray,\n    phi0: float,\n    R_int: float,\n    R_ext: float,\n) -&gt; dict:\n    \"\"\"Computes Stress Intensity Factors (SIFs) using the I-integral method.\n\n    This function calculates the SIFs for modes I, II, III, and T-stress using the I-integral method.\n\n    Note:\n        Line integrals are replaced with domain (surface) integrals.\n\n    Args:\n        domain (Domain): The domain object representing the physical space.\n        model (ElasticModel): The elastic model defining the material properties.\n        u (fem.Function): The displacement field from the finite element solution.\n        xc (np.ndarray): Coordinates of the crack tip.\n        phi0 (float): Angle defining the crack orientation.\n        R_int (float): Inner radius of the theta field transition region.\n        R_ext (float): Outer radius of the theta field transition region.\n\n    Returns:\n        dict: A dictionary containing the computed SIFs (KI, KII, KIII, T).\n    \"\"\"\n    # Get the theta field\n    theta_field = compute_theta_field(domain, xc, R_int, R_ext)\n    theta = theta_field * ufl.as_vector([ufl.cos(phi0), ufl.sin(phi0)])\n    # Compute auxiliary displacement fields\n    u_I_aux = compute_auxiliary_displacement_field(\n        domain, model, xc, phi0, K_I_aux=1.0, K_II_aux=0.0, K_III_aux=0.0, T_aux=0.0\n    )\n    u_II_aux = compute_auxiliary_displacement_field(\n        domain, model, xc, phi0, K_I_aux=0.0, K_II_aux=1.0, K_III_aux=0.0, T_aux=0.0\n    )\n    u_III_aux = compute_auxiliary_displacement_field(\n        domain, model, xc, phi0, K_I_aux=0.0, K_II_aux=0.0, K_III_aux=1.0, T_aux=0.0\n    )\n    u_T_aux = compute_auxiliary_displacement_field(\n        domain, model, xc, phi0, K_I_aux=0.0, K_II_aux=0.0, K_III_aux=0.0, T_aux=1.0\n    )\n    # Compute the I-integrals\n    I_I = compute_I_integral(domain, model, u, u_I_aux, theta)\n    I_II = compute_I_integral(domain, model, u, u_II_aux, theta)\n    I_III = compute_I_integral(domain, model, u, u_III_aux, theta)\n    I_T = compute_I_integral(domain, model, u, u_T_aux, theta)\n    # Compute the SIF\n    K_I = model.Ep_func(xc) / 2 * I_I\n    K_II = model.Ep_func(xc) / 2 * I_II\n    K_III = model.E_func(xc) / (2 * (1 + model.nu_func(xc))) * I_III\n    T = model.Ep_func(xc) * I_T\n    # Return SIF array\n    return {\"KI\": K_I, \"KII\": K_II, \"KIII\": K_III, \"T\": T}\n</code></pre>"},{"location":"API/SIF/#gcrack.sif.compute_auxiliary_displacement_field","title":"<code>compute_auxiliary_displacement_field(domain, model, xc, phi0, K_I_aux=0, K_II_aux=0, K_III_aux=0, T_aux=0)</code>","text":"<p>Computes the auxiliary displacement field for the I-integral method.</p> <p>This function generates the crack tip displacement field under different loading modes (I, II, III, and T-stress).</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain object representing the physical space.</p> required <code>model</code> <code>ElasticModel</code> <p>The elastic model defining the material properties.</p> required <code>xc</code> <code>ndarray</code> <p>Coordinates of the crack tip.</p> required <code>phi0</code> <code>float</code> <p>Angle defining the crack orientation.</p> required <code>K_I_aux</code> <code>float</code> <p>Auxiliary stress intensity factor for mode I. Defaults to 0.</p> <code>0</code> <code>K_II_aux</code> <code>float</code> <p>Auxiliary stress intensity factor for mode II. Defaults to 0.</p> <code>0</code> <code>K_III_aux</code> <code>float</code> <p>Auxiliary stress intensity factor for mode III. Defaults to 0.</p> <code>0</code> <code>T_aux</code> <code>float</code> <p>Auxiliary T-stress. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Expr</code> <p>ufl.core.expr.Expr: The auxiliary displacement field as a UFL expression.</p> Source code in <code>src/gcrack/sif.py</code> <pre><code>def compute_auxiliary_displacement_field(\n    domain: Domain,\n    model: ElasticModel,\n    xc: np.ndarray,\n    phi0: float,\n    K_I_aux: float = 0,\n    K_II_aux: float = 0,\n    K_III_aux: float = 0,\n    T_aux: float = 0,\n) -&gt; ufl.core.expr.Expr:\n    \"\"\"Computes the auxiliary displacement field for the I-integral method.\n\n    This function generates the crack tip displacement field under different loading modes (I, II, III, and T-stress).\n\n    Args:\n        domain (Domain): The domain object representing the physical space.\n        model (ElasticModel): The elastic model defining the material properties.\n        xc (np.ndarray): Coordinates of the crack tip.\n        phi0 (float): Angle defining the crack orientation.\n        K_I_aux (float, optional): Auxiliary stress intensity factor for mode I. Defaults to 0.\n        K_II_aux (float, optional): Auxiliary stress intensity factor for mode II. Defaults to 0.\n        K_III_aux (float, optional): Auxiliary stress intensity factor for mode III. Defaults to 0.\n        T_aux (float, optional): Auxiliary T-stress. Defaults to 0.\n\n    Returns:\n        ufl.core.expr.Expr: The auxiliary displacement field as a UFL expression.\n    \"\"\"\n    # Get the cartesian coordinates\n    x_2D = ufl.SpatialCoordinate(domain.mesh)\n    x = ufl.as_vector([x_2D[0], x_2D[1], 0])\n    x_tip = ufl.as_vector(xc)\n    # Translate the domain to set the crack tip as origin\n    r_vec_init = x - x_tip\n    # Rotate the spatial coordinates to match the crack direction\n    R = ufl.as_tensor(\n        [\n            [ufl.cos(phi0), -ufl.sin(phi0), 0.0],\n            [ufl.sin(phi0), ufl.cos(phi0), 0.0],\n            [0.0, 0.0, 1.0],\n        ]\n    )\n    r_vec = ufl.transpose(R) * r_vec_init\n    # Get the polar coordinates\n    r = ufl.sqrt(ufl.dot(r_vec, r_vec))\n    theta = ufl.atan2(r_vec[1], r_vec[0])\n    # Get the elastic parameters\n    mu = model.mu\n    # Get kappa\n    ka = model.ka\n    # Compute the functions f\n    fx_I = ufl.cos(theta / 2) * (ka - 1 + 2 * ufl.sin(theta / 2) ** 2)\n    fy_I = ufl.sin(theta / 2) * (ka + 1 - 2 * ufl.cos(theta / 2) ** 2)\n    fx_II = ufl.sin(theta / 2) * (ka + 1 + 2 * ufl.cos(theta / 2) ** 2)\n    fy_II = -ufl.cos(theta / 2) * (ka - 1 - 2 * ufl.sin(theta / 2) ** 2)\n    fz_III = 4 * ufl.sin(theta / 2)\n    # Introduce the factor u_fac\n    u_fac = ufl.sqrt(r / (2 * np.pi)) / (2 * mu)\n    # Compute the displacement field for mode I\n    u_I = K_I_aux * u_fac * ufl.as_vector([fx_I, fy_I, 0])\n    # Compute the displacement field for mode II\n    u_II = K_II_aux * u_fac * ufl.as_vector([fx_II, fy_II, 0])\n    # Compute the displacement field for mode III\n    u_III = K_III_aux * u_fac * ufl.as_vector([0, 0, fz_III])\n    # Compute the displacement field for mode T\n    ux_T = (\n        -1 / np.pi * (ka + 1) / (8 * mu) * ufl.ln(r)\n        - 1 / np.pi * 1 / (4 * mu) * ufl.sin(theta) ** 2\n    )\n    uy_T = -1 / np.pi * (ka - 1) / (8 * mu) * theta + 1 / np.pi * 1 / (\n        4 * mu\n    ) * ufl.sin(theta) * ufl.cos(theta)\n    u_T = T_aux * ufl.as_vector([ux_T, uy_T, 0])\n    # Compute the total displacement field and rotate it\n    u_tot = R * (u_I + u_II + u_III + u_T)\n    # Rotate the displacement vectors\n    return u_tot\n</code></pre>"},{"location":"API/SIF/#gcrack.sif.compute_theta_field","title":"<code>compute_theta_field(domain, crack_tip, R_int, R_ext)</code>","text":"<p>Computes the theta field for contour integrals around a crack tip.</p> <p>The theta field is used in the computation of interaction integrals for Stress Intensity Factors (SIFs). It defines a smooth transition between the internal and external radii of the contour.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain object representing the physical space.</p> required <code>crack_tip</code> <code>ndarray</code> <p>Coordinates of the crack tip.</p> required <code>R_int</code> <code>float</code> <p>Internal radius of the contour.</p> required <code>R_ext</code> <code>float</code> <p>External radius of the contour.</p> required <p>Returns:</p> Name Type Description <code>theta</code> <code>Expr</code> <p>The theta field as a UFL expression.</p> Source code in <code>src/gcrack/sif.py</code> <pre><code>def compute_theta_field(\n    domain: Domain, crack_tip: np.ndarray, R_int: float, R_ext: float\n) -&gt; ufl.core.expr.Expr:\n    \"\"\"Computes the theta field for contour integrals around a crack tip.\n\n    The theta field is used in the computation of interaction integrals for Stress Intensity Factors (SIFs).\n    It defines a smooth transition between the internal and external radii of the contour.\n\n    Args:\n        domain (Domain): The domain object representing the physical space.\n        crack_tip (np.ndarray): Coordinates of the crack tip.\n        R_int (float): Internal radius of the contour.\n        R_ext (float): External radius of the contour.\n\n    Returns:\n        theta (ufl.core.expr.Expr): The theta field as a UFL expression.\n    \"\"\"\n    # Get the cartesian coordinates\n    x = ufl.SpatialCoordinate(domain.mesh)\n    # Get the crack tip\n    x_tip = ufl.as_vector(crack_tip[:2])\n    # Get the polar coordinates\n    r = ufl.sqrt(ufl.dot(x - x_tip, x - x_tip))\n    # Define the ufl expression of the theta field\n    theta_temp = (R_ext - r) / (R_ext - R_int)\n    # Clip the value and return\n    return ufl.max_value(0.0, ufl.min_value(theta_temp, 1.0))\n</code></pre>"},{"location":"API/boundary_conditions/","title":"Boundary conditions","text":"<p>Module for defining and processing boundary conditions in finite element simulations.</p> <p>This module provides data structures and functions to handle boundary conditions, including displacement, force, body forces, locked points, and nodal displacements. It is designed to work with the <code>dolfinx</code> library for finite element analysis.</p> <p>Classes:</p> Name Description <code>DisplacementBC</code> <p>Represents a displacement boundary condition.</p> <code>ForceBC</code> <p>Represents a force boundary condition.</p> <code>BodyForce</code> <p>Represents a body force applied within a domain.</p> <code>NodalDisplacement</code> <p>Represents a nodal displacement condition.</p> <code>BoundaryConditions</code> <p>Aggregates all boundary conditions for a simulation.</p> <p>Functions:</p> Name Description <code>get_dirichlet_boundary_conditions</code> <p>Constructs and returns a list of Dirichlet boundary conditions for a given domain and function space.</p>"},{"location":"API/boundary_conditions/#gcrack.boundary_conditions.BodyForce","title":"<code>BodyForce</code>  <code>dataclass</code>","text":"<p>Represents a body force applied within a domain.</p> <p>Attributes:</p> Name Type Description <code>f_imp</code> <code>List[float]</code> <p>Imposed body force values.</p> Source code in <code>src/gcrack/boundary_conditions.py</code> <pre><code>@dataclass\nclass BodyForce:\n    \"\"\"\n    Represents a body force applied within a domain.\n\n    Attributes:\n        f_imp (List[float]): Imposed body force values.\n    \"\"\"\n\n    f_imp: List[float]\n</code></pre>"},{"location":"API/boundary_conditions/#gcrack.boundary_conditions.BoundaryConditions","title":"<code>BoundaryConditions</code>  <code>dataclass</code>","text":"<p>Aggregates all boundary conditions for a simulation.</p> <p>Attributes:</p> Name Type Description <code>displacement_bcs</code> <code>List[DisplacementBC]</code> <p>List of displacement boundary conditions.</p> <code>force_bcs</code> <code>List[ForceBC]</code> <p>List of force boundary conditions.</p> <code>body_forces</code> <code>List[BodyForce]</code> <p>List of body forces applied within the domain.</p> <code>locked_points</code> <code>List[List[float]]</code> <p>List of coordinates for points that are locked (fixed).</p> <code>nodal_displacements</code> <code>List[NodalDisplacement]</code> <p>List of nodal displacement conditions.</p> Source code in <code>src/gcrack/boundary_conditions.py</code> <pre><code>@dataclass\nclass BoundaryConditions:\n    \"\"\"\n    Aggregates all boundary conditions for a simulation.\n\n    Attributes:\n        displacement_bcs (List[DisplacementBC]): List of displacement boundary conditions.\n        force_bcs (List[ForceBC]): List of force boundary conditions.\n        body_forces (List[BodyForce]): List of body forces applied within the domain.\n        locked_points (List[List[float]]): List of coordinates for points that are locked (fixed).\n        nodal_displacements (List[NodalDisplacement]): List of nodal displacement conditions.\n    \"\"\"\n\n    displacement_bcs: List[DisplacementBC]\n    force_bcs: List[ForceBC]\n    body_forces: List[BodyForce]\n    locked_points: List[List[float]]\n    nodal_displacements: List[NodalDisplacement]\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"\n        Checks if all boundary condition lists are empty or None.\n\n        Returns:\n            bool: True if all boundary condition lists are empty or None, False otherwise.\n        \"\"\"\n        return all(\n            not lst\n            for lst in (\n                self.displacement_bcs,\n                self.force_bcs,\n                self.body_forces,\n                self.nodal_displacements,\n            )\n        )\n\n    def _is_null_or_nan(self, value):\n        if isinstance(value, (int, float)):\n            return value == 0 or isnan(value)\n        elif isinstance(value, str):\n            return False\n\n    def is_null(self) -&gt; bool:\n        \"\"\"\n        Check if all boundary conditions and forces are zero, NaN, or if all lists are empty.\n\n        Returns:\n            bool: True if all lists are empty or all their values are zero or NaN, False otherwise.\n        \"\"\"\n\n        conditions = [\n            all(\n                self._is_null_or_nan(comp)\n                for bc in self.displacement_bcs\n                for comp in bc.u_imp\n            ),\n            all(\n                self._is_null_or_nan(comp) for bc in self.force_bcs for comp in bc.f_imp\n            ),\n            all(\n                self._is_null_or_nan(comp)\n                for bc in self.body_forces\n                for comp in bc.f_imp\n            ),\n            all(\n                self._is_null_or_nan(comp)\n                for bc in self.nodal_displacements\n                for comp in bc.u_imp\n            ),\n        ]\n        return all(conditions)\n</code></pre>"},{"location":"API/boundary_conditions/#gcrack.boundary_conditions.BoundaryConditions.is_empty","title":"<code>is_empty()</code>","text":"<p>Checks if all boundary condition lists are empty or None.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all boundary condition lists are empty or None, False otherwise.</p> Source code in <code>src/gcrack/boundary_conditions.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"\n    Checks if all boundary condition lists are empty or None.\n\n    Returns:\n        bool: True if all boundary condition lists are empty or None, False otherwise.\n    \"\"\"\n    return all(\n        not lst\n        for lst in (\n            self.displacement_bcs,\n            self.force_bcs,\n            self.body_forces,\n            self.nodal_displacements,\n        )\n    )\n</code></pre>"},{"location":"API/boundary_conditions/#gcrack.boundary_conditions.BoundaryConditions.is_null","title":"<code>is_null()</code>","text":"<p>Check if all boundary conditions and forces are zero, NaN, or if all lists are empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all lists are empty or all their values are zero or NaN, False otherwise.</p> Source code in <code>src/gcrack/boundary_conditions.py</code> <pre><code>def is_null(self) -&gt; bool:\n    \"\"\"\n    Check if all boundary conditions and forces are zero, NaN, or if all lists are empty.\n\n    Returns:\n        bool: True if all lists are empty or all their values are zero or NaN, False otherwise.\n    \"\"\"\n\n    conditions = [\n        all(\n            self._is_null_or_nan(comp)\n            for bc in self.displacement_bcs\n            for comp in bc.u_imp\n        ),\n        all(\n            self._is_null_or_nan(comp) for bc in self.force_bcs for comp in bc.f_imp\n        ),\n        all(\n            self._is_null_or_nan(comp)\n            for bc in self.body_forces\n            for comp in bc.f_imp\n        ),\n        all(\n            self._is_null_or_nan(comp)\n            for bc in self.nodal_displacements\n            for comp in bc.u_imp\n        ),\n    ]\n    return all(conditions)\n</code></pre>"},{"location":"API/boundary_conditions/#gcrack.boundary_conditions.DisplacementBC","title":"<code>DisplacementBC</code>  <code>dataclass</code>","text":"<p>Represents a displacement boundary condition.</p> <p>Attributes:</p> Name Type Description <code>boundary_id</code> <code>int</code> <p>Unique identifier for the boundary where the displacement is applied.</p> <code>u_imp</code> <code>List[float]</code> <p>Imposed displacement values for the boundary.</p> Source code in <code>src/gcrack/boundary_conditions.py</code> <pre><code>@dataclass\nclass DisplacementBC:\n    \"\"\"\n    Represents a displacement boundary condition.\n\n    Attributes:\n        boundary_id (int): Unique identifier for the boundary where the displacement is applied.\n        u_imp (List[float]): Imposed displacement values for the boundary.\n    \"\"\"\n\n    boundary_id: int\n    u_imp: List[float]\n</code></pre>"},{"location":"API/boundary_conditions/#gcrack.boundary_conditions.ForceBC","title":"<code>ForceBC</code>  <code>dataclass</code>","text":"<p>Represents a force boundary condition.</p> <p>Attributes:</p> Name Type Description <code>boundary_id</code> <code>int</code> <p>Unique identifier for the boundary where the force is applied.</p> <code>f_imp</code> <code>List[float]</code> <p>Imposed force values for the boundary.</p> Source code in <code>src/gcrack/boundary_conditions.py</code> <pre><code>@dataclass\nclass ForceBC:\n    \"\"\"\n    Represents a force boundary condition.\n\n    Attributes:\n        boundary_id (int): Unique identifier for the boundary where the force is applied.\n        f_imp (List[float]): Imposed force values for the boundary.\n    \"\"\"\n\n    boundary_id: int\n    f_imp: List[float]\n</code></pre>"},{"location":"API/boundary_conditions/#gcrack.boundary_conditions.NodalDisplacement","title":"<code>NodalDisplacement</code>  <code>dataclass</code>","text":"<p>Represents a nodal displacement condition.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>List[float]</code> <p>Coordinates of the node.</p> <code>u_imp</code> <code>List[float]</code> <p>Imposed displacement values for the node.</p> Source code in <code>src/gcrack/boundary_conditions.py</code> <pre><code>@dataclass\nclass NodalDisplacement:\n    \"\"\"\n    Represents a nodal displacement condition.\n\n    Attributes:\n        x (List[float]): Coordinates of the node.\n        u_imp (List[float]): Imposed displacement values for the node.\n    \"\"\"\n\n    x: List[float]\n    u_imp: List[float]\n</code></pre>"},{"location":"API/boundary_conditions/#gcrack.boundary_conditions.get_dirichlet_boundary_conditions","title":"<code>get_dirichlet_boundary_conditions(domain, V_u, bcs)</code>","text":"<p>Constructs and returns a list of Dirichlet boundary conditions for a given domain and function space.</p> <p>This function processes displacement boundary conditions, locked points, and nodal displacements to create Dirichlet boundary conditions for use in finite element simulations.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The computational domain, including mesh and facet markers.</p> required <code>V_u</code> <code>FunctionSpace</code> <p>The function space for the displacement field.</p> required <code>bcs</code> <code>BoundaryConditions</code> <p>An object containing all boundary conditions, including displacement, locked points, and nodal displacements.</p> required <p>Returns:</p> Type Description <code>List[dirichletbc]</code> <p>A list of Dirichlet boundary conditions for the displacement field.</p> Notes <ul> <li>For each displacement boundary condition, the function locates the relevant degrees of freedom (DOFs)   and creates a Dirichlet boundary condition for each component.</li> <li>Locked points are treated as fixed (zero displacement) boundary conditions.</li> <li>Nodal displacements are imposed at specific nodes, with support for multi-component fields.</li> <li>The function handles both scalar and vector function spaces.</li> </ul> Source code in <code>src/gcrack/boundary_conditions.py</code> <pre><code>def get_dirichlet_boundary_conditions(\n    domain: Domain,\n    V_u: dolfinx.fem.FunctionSpace,\n    bcs: BoundaryConditions,\n) -&gt; List[dolfinx.fem.dirichletbc]:\n    \"\"\"\n    Constructs and returns a list of Dirichlet boundary conditions for a given domain and function space.\n\n    This function processes displacement boundary conditions, locked points, and nodal displacements to create Dirichlet boundary conditions for use in finite element simulations.\n\n    Args:\n        domain (Domain): The computational domain, including mesh and facet markers.\n        V_u (dolfinx.fem.FunctionSpace): The function space for the displacement field.\n        bcs (BoundaryConditions): An object containing all boundary conditions, including displacement, locked points, and nodal displacements.\n\n    Returns:\n        A list of Dirichlet boundary conditions for the displacement field.\n\n    Notes:\n        - For each displacement boundary condition, the function locates the relevant degrees of freedom (DOFs)\n          and creates a Dirichlet boundary condition for each component.\n        - Locked points are treated as fixed (zero displacement) boundary conditions.\n        - Nodal displacements are imposed at specific nodes, with support for multi-component fields.\n        - The function handles both scalar and vector function spaces.\n    \"\"\"\n    # Get the dimensions\n    dim = domain.mesh.geometry.dim\n    fdim = dim - 1\n    # Get the number of components\n    N_comp = V_u.value_shape[0]\n    # Get the facets markers\n    facet_markers = domain.facet_markers\n    # Get the facets indices\n    boundary_facets = {\n        u_bc.boundary_id: facet_markers.indices[\n            facet_markers.values == u_bc.boundary_id\n        ]\n        for u_bc in bcs.displacement_bcs\n    }\n    # Get boundary dofs (per comp)\n    if N_comp == 1:  # Anti-plane\n        comp = 0\n        boundary_dofs = {\n            f\"{facet_id}_{comp}\": fem.locate_dofs_topological(V_u, fdim, boundary_facet)\n            for facet_id, boundary_facet in boundary_facets.items()\n        }\n    else:\n        boundary_dofs = {\n            f\"{facet_id}_{comp}\": fem.locate_dofs_topological(\n                (V_u.sub(comp), V_u.sub(comp).collapse()[0]),\n                fdim,\n                boundary_facet,\n            )\n            for comp in range(N_comp)\n            for facet_id, boundary_facet in boundary_facets.items()\n        }\n    # Create variables to store bcs and loading functions\n    dirichlet_bcs = []\n    # Iterage through the displacement loadings\n    for u_bc in bcs.displacement_bcs:\n        # Iterate through the axis\n        for comp in range(N_comp):\n            # Parse the boundary condition\n            V_u_comp = V_u if N_comp == 1 else V_u.sub(comp).collapse()[0]\n            bc_func = parse_expression(u_bc.u_imp[comp], V_u_comp)\n            if bc_func is None:\n                continue\n            # Get the DOFs\n            boundary_dof = boundary_dofs[f\"{u_bc.boundary_id}_{comp}\"]\n            # Create the Dirichlet boundary condition\n            if N_comp == 1:  # TODO: Clean (idk why no syntax works in both cases)\n                bc = fem.dirichletbc(bc_func, boundary_dof)\n            else:\n                bc = fem.dirichletbc(bc_func, boundary_dof, V_u)\n            # Add the boundary conditions to the list\n            dirichlet_bcs.append(bc)\n\n    # Add the locked points\n    for p in bcs.locked_points:\n        # Define the location function\n        def on_locked_point(x):\n            return np.logical_and(np.isclose(x[0], p[0]), np.isclose(x[1], p[1]))\n\n        # Define locked point boundary condition for the x and y components\n        locked_dofs = fem.locate_dofs_geometrical(V_u, on_locked_point)\n        locked_bc = fem.dirichletbc(np.array([0.0] * N_comp), locked_dofs, V_u)\n        # Append the boundary condition to the list of boundary condition\n        dirichlet_bcs.append(locked_bc)\n\n    # Add the nodal displacements\n    for nd in bcs.nodal_displacements:\n        # Extract the quantities\n        p = np.array(nd.x)\n        u_imp = nd.u_imp\n\n        # Define the location function\n        def on_locked_point(x):\n            return np.logical_and(np.isclose(x[0], p[0]), np.isclose(x[1], p[1]))\n\n        for comp in range(N_comp):\n            # Check if the imposed displement is nan\n            if isnan(u_imp[comp]):\n                continue\n            # Get the locked dofs\n            dof = fem.locate_dofs_geometrical(\n                (V_u.sub(comp), V_u.sub(comp).collapse()[0]), on_locked_point\n            )\n            if not dof:\n                raise ValueError(\n                    f\"No node found at {nd.x} to impose nodal displacement.\"\n                )\n            # Parse the nodal value\n            V_u_comp = V_u if N_comp == 1 else V_u.sub(comp).collapse()[0]\n            bc_func = parse_expression(u_imp[comp], V_u_comp)\n            # Create the Dirichlet boundary condition\n            if N_comp == 1:  # TODO: Clean (idk why no syntax works in both cases)\n                bc = fem.dirichletbc(bc_func, dof)\n            else:\n                bc = fem.dirichletbc(bc_func, dof, V_u)\n            # Append the boundary condition to the list\n            dirichlet_bcs.append(bc)\n    return dirichlet_bcs\n</code></pre>"},{"location":"API/domain/","title":"Domain","text":"<p>This module provides functionality to represent the domain for the problem.</p> <p>Classes:</p> Name Description <code>Domain</code> <p>Represents the domain for the problem.</p>"},{"location":"API/domain/#gcrack.domain.Domain","title":"<code>Domain</code>","text":"<p>Class representing the domain for the problem.</p> <p>This class reads the mesh from a GMSH file and locates physical groups.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>The dimension of the domain.</p> <code>mesh</code> <code>Mesh</code> <p>The mesh representing the domain.</p> <code>cell_tags</code> <code>ndarray</code> <p>Array containing cell tags.</p> <code>facet_tags</code> <code>ndarray</code> <p>Array containing facet tags.</p> <code>boundary_facets</code> <code>dict</code> <p>Dictionary containing boundary facets grouped by physical group name.</p> Source code in <code>src/gcrack/domain.py</code> <pre><code>class Domain:\n    \"\"\"Class representing the domain for the problem.\n\n    This class reads the mesh from a GMSH file and locates physical groups.\n\n    Attributes:\n        dim (int): The dimension of the domain.\n        mesh (dolfinx.Mesh): The mesh representing the domain.\n        cell_tags (numpy.ndarray): Array containing cell tags.\n        facet_tags (numpy.ndarray): Array containing facet tags.\n        boundary_facets (dict): Dictionary containing boundary facets grouped by physical group name.\n    \"\"\"\n\n    def __init__(self, gmsh_model):\n        \"\"\"\n        Initialize the Domain.\n        \"\"\"\n        # Get the dimension\n        self.dim = gmsh_model.getDimension()\n        # Generate mesh data from the gmsh model\n        self.mesh_data = io.gmsh.model_to_mesh(\n            gmsh_model, MPI.COMM_WORLD, 0, gdim=self.dim\n        )\n        # Extract the mesh and the tags\n        self.mesh = self.mesh_data.mesh\n        self.cell_markers = self.mesh_data.cell_tags\n        self.facet_markers = self.mesh_data.facet_tags\n</code></pre>"},{"location":"API/domain/#gcrack.domain.Domain.__init__","title":"<code>__init__(gmsh_model)</code>","text":"<p>Initialize the Domain.</p> Source code in <code>src/gcrack/domain.py</code> <pre><code>def __init__(self, gmsh_model):\n    \"\"\"\n    Initialize the Domain.\n    \"\"\"\n    # Get the dimension\n    self.dim = gmsh_model.getDimension()\n    # Generate mesh data from the gmsh model\n    self.mesh_data = io.gmsh.model_to_mesh(\n        gmsh_model, MPI.COMM_WORLD, 0, gdim=self.dim\n    )\n    # Extract the mesh and the tags\n    self.mesh = self.mesh_data.mesh\n    self.cell_markers = self.mesh_data.cell_tags\n    self.facet_markers = self.mesh_data.facet_tags\n</code></pre>"},{"location":"API/exporters/","title":"Exporters","text":"<p>Module for exporting simulation results in CSV and VTK formats.</p> <p>This module provides utility functions for exporting FEniCSx function data to VTK files for visualization, appending simulation results to CSV files, and cleaning up VTK output directories by gathering .pvtu files into a single .pvd file.</p> <p>Functions:</p> Name Description <code>export_res_to_csv</code> <p>Appends a dictionary of results to a CSV file. The keys of the dictionary become the column headers, and the values are appended as a row.</p> <code>export_function</code> <p>Exports a FEniCS function to a VTK file. The filename is constructed using the function name and the provided time step <code>t</code>.</p> <code>clean_vtk_files</code> <p>Cleans a directory by removing existing .pvd files and creating a new .pvd file that lists all .pvtu files with their corresponding timesteps.</p>"},{"location":"API/exporters/#gcrack.exporters.clean_vtk_files","title":"<code>clean_vtk_files(res_dir)</code>","text":"<p>Clean the specified directory by removing existing .pvd files and create a new .pvd file listing all .pvtu files.</p> <p>This function removes all existing .pvd files in the given directory and creates a new .pvd file that lists all .pvtu files with their corresponding timesteps. The new .pvd file is named 'displacement.pvd'.</p> <p>Parameters:</p> Name Type Description Default <code>res_dir</code> <code>Path</code> <p>The path to the directory containing .pvtu and .vtu files.</p> required Source code in <code>src/gcrack/exporters.py</code> <pre><code>def clean_vtk_files(res_dir: Path):\n    \"\"\"\n    Clean the specified directory by removing existing .pvd files and create a new .pvd file listing all .pvtu files.\n\n    This function removes all existing .pvd files in the given directory and creates a new .pvd file that lists all .pvtu files\n    with their corresponding timesteps. The new .pvd file is named 'displacement.pvd'.\n\n    Args:\n        res_dir (Path): The path to the directory containing .pvtu and .vtu files.\n    \"\"\"\n\n    # Remove existing .pvd files\n    for pvd_file in res_dir.glob(\"*.pvd\"):\n        pvd_file.unlink()\n\n    # Collect all .pvtu files and sort them\n    pvtu_files = sorted(res_dir.glob(\"*.pvtu\"))\n\n    # Create a new .pvd file content\n    pvd_content = (\n        '&lt;VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\"&gt;\\n'\n    )\n    pvd_content += \"  &lt;Collection&gt;\\n\"\n\n    for timestep, pvtu_file in enumerate(pvtu_files):\n        pvd_content += f'    &lt;DataSet timestep=\"{timestep}\" group=\"\" part=\"0\" file=\"{pvtu_file.name}\"/&gt;\\n'\n\n    pvd_content += \"  &lt;/Collection&gt;\\n\"\n    pvd_content += \"&lt;/VTKFile&gt;\"\n\n    # Write the new .pvd file\n    combined_pvd_path = res_dir / \"displacement.pvd\"\n    with combined_pvd_path.open(\"w\") as file:\n        file.write(pvd_content)\n\n    print(f\"Created displacement.pvd with {len(pvtu_files)} timesteps.\")\n</code></pre>"},{"location":"API/exporters/#gcrack.exporters.export_function","title":"<code>export_function(u, t, dir_path)</code>","text":"<p>Export a FEniCS function to a VTK file.</p> <p>This function writes the given FEniCS function to a VTK file for visualization. The filename is constructed using the function name with the provided time step <code>t</code>, and the file is saved in the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Function</code> <p>The FEniCS function to be exported.</p> required <code>t</code> <code>int</code> <p>The time step used to construct the filename.</p> required <code>dir_path</code> <code>Path</code> <p>The path to the directory where the VTK file will be saved.</p> required Source code in <code>src/gcrack/exporters.py</code> <pre><code>def export_function(u: fem.Function, t: int, dir_path: Path):\n    \"\"\"\n    Export a FEniCS function to a VTK file.\n\n    This function writes the given FEniCS function to a VTK file for visualization. The filename\n    is constructed using the function name with the provided time step `t`, and the file is saved\n    in the specified directory.\n\n    Args:\n        u (fem.Function): The FEniCS function to be exported.\n        t (int): The time step used to construct the filename.\n        dir_path (Path): The path to the directory where the VTK file will be saved.\n    \"\"\"\n    # Get function info\n    V = u.function_space\n    vtkfile = io.VTKFile(V.mesh.comm, dir_path / f\"{u.name}_{t:04d}_.pvd\", \"w\")\n    vtkfile.write_function(u, 0)\n    vtkfile.close()\n</code></pre>"},{"location":"API/exporters/#gcrack.exporters.export_heterogeneous_parameters","title":"<code>export_heterogeneous_parameters(model, ela_pars, dir_path)</code>","text":"<p>Export the heterogeneous parameters into a VTK file.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ElasticModel</code> <p>ElasticModel in gcrack.</p> required <code>ela_pars</code> <code>dict</code> <p>Input (raw) parameters of the elastic model.</p> required <code>dir_path</code> <code>Path</code> <p>The path to the directory where the VTK file will be saved.</p> required Source code in <code>src/gcrack/exporters.py</code> <pre><code>def export_heterogeneous_parameters(model, ela_pars: dict, dir_path: Path):\n    \"\"\"\n    Export the heterogeneous parameters into a VTK file.\n\n    Args:\n        model (gcrack.ElasticModel): ElasticModel in gcrack.\n        ela_pars (dict): Input (raw) parameters of the elastic model.\n        dir_path (Path): The path to the directory where the VTK file will be saved.\n    \"\"\"\n    # At first load step, also export the heterogeneous parameters\n    if isinstance(ela_pars[\"E\"], str):\n        V = model.E.function_space\n        model.E.name = \"Young Modulus\"\n        vtkfile = io.VTKFile(V.mesh.comm, dir_path / \"YoungModulus.pvd\", \"w\")\n        vtkfile.write_function(model.E, 0)\n        vtkfile.close()\n    if isinstance(ela_pars[\"nu\"], str):\n        V = model.nu.function_space\n        model.nu.name = \"Poisson Ratio\"\n        vtkfile = io.VTKFile(V.mesh.comm, dir_path / \"PoissonRatio.pvd\", \"w\")\n        vtkfile.write_function(model.nu, 0)\n        vtkfile.close()\n</code></pre>"},{"location":"API/exporters/#gcrack.exporters.export_res_to_csv","title":"<code>export_res_to_csv(res, filename)</code>","text":"<p>Append the res dictionary to a CSV file.</p> <p>This function appends the contents of a dictionary to a CSV file. The keys of the dictionary become the column headers in the CSV file, and the values are appended to the associated column.</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>dict</code> <p>The dictionary containing row data to be appended.          The keys are column headers and the values are the row values.</p> required <code>filename</code> <code>str</code> <p>The name of the CSV file to be created.</p> required Source code in <code>src/gcrack/exporters.py</code> <pre><code>def export_res_to_csv(res: dict, filename: str):\n    \"\"\"\n    Append the res dictionary to a CSV file.\n\n    This function appends the contents of a dictionary to a CSV file. The keys of the dictionary\n    become the column headers in the CSV file, and the values are appended to the associated column.\n\n    Args:\n        res (dict): The dictionary containing row data to be appended.\n                     The keys are column headers and the values are the row values.\n        filename (str): The name of the CSV file to be created.\n    \"\"\"\n    with open(filename, mode=\"a\", newline=\"\", encoding=\"utf-8\") as file:\n        writer = csv.DictWriter(file, fieldnames=list(res.keys()))\n        if res[\"t\"] == 0:\n            writer.writeheader()\n        writer.writerow(res)\n</code></pre>"},{"location":"API/gcrack/","title":"Gcrack","text":"<p>Main entry point for the GCrack simulation framework.</p> <p>This module serves as the entry point for simulating crack propagation in elastic materials using the Finite Element Method (FEM). It contains the entire simulation workflow, including mesh generation, boundary condition application, solving the elastic problem, computing Stress Intensity Factors (SIFs), and post-processing results.</p> <p>The simulation is driven by the <code>GCrackBase</code> abstract base class, which users must subclass to define problem-specific parameters and behaviors. The workflow includes:</p> <ul> <li>Generating the mesh for the cracked domain.</li> <li>Applying boundary conditions (displacements, forces, body forces, locked points, etc.).</li> <li>Solving the elastic problem for both controlled and prescribed boundary conditions.</li> <li>Computing SIFs using the specified method (e.g., I-integral).</li> <li>Determining the crack propagation angle and load factor.</li> <li>Post-processing results, including computing energies, reaction forces, and displacements.</li> <li>Exporting results to VTK and CSV formats.</li> </ul> <p>Classes:</p> Name Description <code>GCrackBase</code> <p>Abstract base class for defining and running crack propagation simulations. Users must subclass this class and implement abstract methods to define problem-specific parameters and behaviors.</p> <p>Attributes:</p> Name Type Description <code>None</code> <p>All attributes and methods are encapsulated within the <code>GCrackBase</code> class.</p> Usage <p>To run a simulation, users must:</p> <ol> <li>Subclass <code>GCrackBase</code> and implement all abstract methods.</li> <li>Instantiate the subclass with the required parameters.</li> <li>Call the <code>run()</code> method to execute the simulation.</li> </ol> <p>Example:</p> <pre><code>from gcrack.main import GCrackBase\nclass MySimulation(GCrackBase):\n    def generate_mesh(self, crack_points):\n        # Implement mesh generation logic\n    def locate_measured_displacement(self):\n        # Implement logic to locate measured displacement\n    # Implement other abstract methods\n\nsimulation = MySimulation(E=1e5, nu=0.3, da=0.1, Nt=10, xc0=np.array([0, 0, 0]))\nsimulation.run()\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase","title":"<code>GCrackBase</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>GCrackBase is an abstract base class for simulating crack propagation in elastic materials using the Finite Element Method (FEM).</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>@dataclass\nclass GCrackBase(ABC):\n    \"\"\"\n    GCrackBase is an abstract base class for simulating crack propagation in elastic materials using the Finite Element Method (FEM).\n    \"\"\"\n\n    E: float\n    \"\"\"E (float): Young's modulus of the material.\"\"\"\n    nu: float\n    \"\"\"nu (float): Poisson's ratio of the material.\"\"\"\n    da: float\n    \"\"\"da (float): Crack increment length.\"\"\"\n    Nt: int\n    \"\"\"Nt (int): Number of crack increment.\"\"\"\n    xc0: np.array\n    \"\"\"xc0 (np.array): Initial crack tip coordinates.\"\"\"\n    assumption_2D: str\n    \"\"\"assumption_2D (str): Assumption for 2D elasticity (e.g., 'plane stress', 'plane strain').\"\"\"\n    pars: dict\n    \"\"\"pars (dict): User-defined parameters passed to user-defined functions.\"\"\"\n    l0: Optional[float] = 0.0\n    \"\"\"l0 (Optional[float]): Initial load factor, defaults to 0.0.\"\"\"\n    phi0: Optional[float] = 0.0\n    \"\"\"phi0 (Optional[float]): Initial crack propagation angle, defaults to 0.0.\"\"\"\n    s: Optional[float] = 0\n    \"\"\"s (Optional[float]): Internal length associated with T-stress, defaults to 0.\"\"\"\n    sif_method: Optional[str] = \"I-integral\"\n    \"\"\"sif_method (Optional[str]): Method for computing Stress Intensity Factors (SIFs), defaults to \"I-integral\".\"\"\"\n    criterion: Optional[str] = \"gmerr\"\n    \"\"\"criterion (Optional[str]): Criterion for crack propagation, defaults to \"gmerr\".\"\"\"\n    name: Optional[str] = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n    \"\"\"name (Optional[str]): Name of the simulation used to name the results directory.\"\"\"\n    no_propagation: Optional[bool] = False\n    \"\"\"no_propagation (Optional[bool]): Flag to only run skip the crack propagation phase.\"\"\"\n    no_meshing: Optional[bool] = False\n    \"\"\"no_meshing (Optional[bool]): Flag to skip mesh generation when a mesh has already been created.\"\"\"\n\n    def __post_init__(self):\n        # Compute the radii for the SIF evaluation\n        self.R_int = 1 / 8 * self.da\n        self.R_ext = 1 / 4 * self.da\n\n    @abstractmethod\n    def generate_mesh(self, crack_points) -&gt; gmsh.model:\n        pass\n\n    @abstractmethod\n    def locate_measured_displacement(self) -&gt; List[float]:\n        \"\"\"Define the point where the displacement is measured.\n\n        Returns:\n            List: Coordinate of the point where the displacement is measured\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def locate_measured_forces(self) -&gt; int:\n        \"\"\"Define the boundary where the reaction force are measured.\n\n        Returns:\n            int: Identifier (id) of the boundary in GMSH.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def Gc(self, phi: float | np.ndarray) -&gt; float | np.ndarray:\n        \"\"\"Define the critical energy release rate.\n\n        To account for material anisotropy, the critical energy release rate can depend on the crack orientation $\\\\varphi$\n\n        Args:\n            phi (np.ndarray): Crack angle.\n\n        Returns:\n            np.ndarray: Value of the critical energy release rate.\n\n        Note:\n            The intput and output should be arrays for practical details in the minimization of the load factor.\n        \"\"\"\n        pass\n\n    def define_locked_points(self) -&gt; List[List[float]]:\n        \"\"\"Define the list of locked points.\n\n        Returns:\n            List[List[float]]: A list of points (list) coordinates.\n        \"\"\"\n        return []\n\n    def define_nodal_displacements(self) -&gt; List[NodalDisplacement]:\n        \"\"\"Define a list of imposed nodal displacements.\n\n        Returns:\n            List[NodalDisplacements]: A list of NodalDisplacement.\n        \"\"\"\n        return []\n\n    def define_controlled_displacements(self) -&gt; List[DisplacementBC]:\n        \"\"\"Define the displacement boundary conditions controlled by the load factor.\n\n        Returns:\n            List[DisplacementBC]: List of DisplacementBC(boundary_id, u_imp) where boundary_id is the boundary id (int number) in GMSH, and u_imp is the displacement vector (componements can be nan to let it free).\n        \"\"\"\n        return []\n\n    def define_controlled_forces(self) -&gt; List[ForceBC]:\n        \"\"\"Define the force boundary conditions controlled by the load factor.\n\n        Returns:\n            List[ForceBC]: List of ForceBC(boundary_id, f_imp) where boundary_id is the boundary id (int number) in GMSH, and f_imp is the force vector.\n        \"\"\"\n        return []\n\n    def define_controlled_body_forces(self) -&gt; List[BodyForce]:\n        \"\"\"Define the controlled body forces that are affected by the load factor.\n\n        Returns:\n            List[BodyForce]: List of BodyForce (f_imp) where f_imp is the force vector.\n        \"\"\"\n        return []\n\n    def define_prescribed_displacements(self) -&gt; List[DisplacementBC]:\n        \"\"\"Define the prescribed displacement boundary conditions that are not affected by the load factor.\n\n        Returns:\n            List[DisplacementBC]: List of DisplacementBC(boundary_id, u_imp) where boundary_id is the boundary id (int number) in GMSH, and u_imp is the displacement vector (componements can be nan to let it free).\n        \"\"\"\n        return []\n\n    def define_prescribed_forces(self) -&gt; List[ForceBC]:\n        \"\"\"Define the prescribed force boundary conditions that are not affected by the load factor.\n\n        Returns:\n            List[ForceBC]: List of ForceBC(boundary_id, f_imp) where boundary_id is the boundary id (int number) in GMSH, and f_imp is the force vector.\n        \"\"\"\n        return []\n\n    def define_prescribed_body_forces(self) -&gt; List[BodyForce]:\n        \"\"\"Define the prescribed body forces that are not affected by the load factor.\n\n        Returns:\n            List[BodyForce]: List of BodyForce (f_imp) where f_imp is the force vector.\n        \"\"\"\n        return []\n\n    def user_load_step_initialization(self, res: dict) -&gt; None:\n        \"\"\"User-defined load step initialization.\n\n        Customize load step initialization using results from the previous step.\n        This can include creating custom variables for boundary conditions.\n        This function is called at the very beginning of the load step.\n        \"\"\"\n        ...\n\n    def run(self):\n        \"\"\"Executes the crack propagation simulation workflow.\n\n        This method manages the entire simulation process, including:\n\n        - Initializing the GMSH environment and results directory.\n        - Generating the mesh for the cracked domain (unless `no_meshing` is True).\n        - Applying boundary conditions (displacements, forces, body forces, locked points, etc.).\n        - Solving the elastic problem for both controlled and prescribed boundary conditions.\n        - Computing Stress Intensity Factors (SIFs) using the specified method.\n        - Determining the crack propagation angle and load factor.\n        - Post-processing results, including computing energies, reaction forces, and displacements.\n        - Exporting results to VTK and CSV formats.\n\n        The simulation runs for `self.Nt` load steps, updating the crack tip position and\n        boundary conditions at each step. Results are stored in a dictionary and exported\n        to the results directory.\n\n        Steps:\n\n        1. Initialize GMSH and create the results directory.\n        2. For each load step:\n            1. Generate the mesh (if `no_meshing` is False).\n            2. Define and apply boundary conditions.\n            3. Solve the elastic problem for controlled and prescribed boundary conditions.\n            4. Compute SIFs for both controlled and prescribed problems.\n            5. Determine the crack propagation angle and load factor.\n            6. Post-process results (e.g., compute energies, reaction forces, displacements).\n            g. Export results to VTK and CSV files.\n        3. Clean up and finalize the simulation.\n\n        Note:\n            - The `no_meshing` flag can be set to skip mesh generation if a mesh already exists.\n            - The `no_propagation` flag can be set to skip crack propagation and use arbitrary load factor/crack propagation angle.\n        \"\"\"\n        # Initialize GMSH\n        gmsh.initialize()\n        gmsh.option.setNumber(\"General.Terminal\", 0)  # Disable terminal output\n        gmsh.option.setNumber(\"Mesh.Algorithm\", 5)\n        # 1: meshadapt; 5: delaunay, 6: frontal-delaunay\n\n        # Initialize export directory\n        dir_name = Path(\"results_\" + self.name)\n        dir_name.mkdir(parents=True, exist_ok=True)\n\n        # Get the elastic parameters\n        ela_pars = {\n            \"E\": self.E,\n            \"nu\": self.nu,\n            \"2D_assumption\": self.assumption_2D,\n        }\n        # Initialize the crack points\n        crack_points = [self.xc0]\n        # Initialize results storage\n        res = {\n            \"t\": 0,\n            \"a\": 0,\n            \"phi\": self.phi0,\n            \"lambda\": self.l0,\n            \"xc_1\": crack_points[-1][0],\n            \"xc_2\": crack_points[-1][1],\n            \"xc_3\": crack_points[-1][2],\n            \"uimp_1\": 0.0,\n            \"uimp_2\": 0.0,\n            \"fimp_1\": 0.0,\n            \"fimp_2\": 0.0,\n            \"KI\": 0.0,\n            \"KII\": 0.0,\n            \"T\": 0.0,\n            \"elastic_energy\": 0.0,\n            \"fracture_dissipation\": 0.0,\n            \"external_work\": 0.0,\n        }\n\n        for t in range(1, self.Nt + 1):\n            print(f\"\\nLOAD STEP {t}\")\n            # Get current crack properties\n            phi0 = res[\"phi\"]\n\n            # Run the user defined load step initialization\n            self.user_load_step_initialization(res)\n\n            # Generate the mesh\n            if not self.no_meshing:\n                print(\"\u2502  Meshing the cracked domain\")\n                gmsh_model = self.generate_mesh(crack_points)\n            else:\n                print(\"\u2502  Skip meshing (no_meshing = True)\")\n\n            # Get the controlled boundary conditions\n            controlled_bcs = BoundaryConditions(\n                displacement_bcs=self.define_controlled_displacements(),\n                force_bcs=self.define_controlled_forces(),\n                body_forces=self.define_controlled_body_forces(),\n                locked_points=self.define_locked_points(),\n                nodal_displacements=self.define_nodal_displacements(),\n            )\n\n            # Get the controlled boundary conditions\n            prescribed_bcs = BoundaryConditions(\n                displacement_bcs=self.define_prescribed_displacements(),\n                force_bcs=self.define_prescribed_forces(),\n                body_forces=self.define_prescribed_body_forces(),\n                locked_points=self.define_locked_points(),\n                nodal_displacements=self.define_nodal_displacements(),\n            )\n\n            # Define the domain\n            if not self.no_meshing:\n                self.domain = Domain(gmsh_model)\n\n            # Define an elastic model\n            model = ElasticModel(ela_pars, self.domain)\n            if t == 1:\n                export_heterogeneous_parameters(model, ela_pars, dir_name)\n\n            print(\"\u2502  Solve the controlled elastic problem with FEM\")\n            # Solve the controlled elastic problem\n            u_controlled = solve_elastic_problem(self.domain, model, controlled_bcs)\n\n            print(f\"\u2502  Compute the SIFs for the controlled problem ({self.sif_method})\")\n            # Compute the SIFs for the controlled problem\n            SIFs_controlled = compute_SIFs(\n                self.domain,\n                model,\n                u_controlled,\n                crack_points[-1],\n                phi0,\n                self.R_int,\n                self.R_ext,\n                self.sif_method,\n            )\n\n            # Tackle the prescribed problem\n            if not prescribed_bcs.is_null():\n                print(\"\u2502  Solve the prescribed elastic problem with FEM\")\n                # Solve the prescribed elastic problem\n                u_prescribed = solve_elastic_problem(self.domain, model, prescribed_bcs)\n                # Compute the SIFs for the prescribed problem\n                SIFs_prescribed = compute_SIFs(\n                    self.domain,\n                    model,\n                    u_prescribed,\n                    crack_points[-1],\n                    phi0,\n                    self.R_int,\n                    self.R_ext,\n                    self.sif_method,\n                )\n            else:\n                # Set the prescribed displacement to 0\n                u_prescribed = u_controlled.copy()\n                u_prescribed.x.array[:] = 0.0\n                # Set the SIFs to 0\n                SIFs_prescribed = {key: 0.0 for key in SIFs_controlled}\n                print(\"\u2502  No prescribed BCs\")\n\n            # Compute the load factor and crack angle.\n            print(\"\u2502  Determination of propagation angle and load factor\")\n            if not self.no_propagation:\n                load_factor_solver = LoadFactorSolver(model, self.Gc, crack_points[-1])\n                opti_res = load_factor_solver.solve(\n                    phi0, SIFs_controlled, SIFs_prescribed, self.s\n                )\n                # Get the results\n                phi_ = opti_res[0]\n                lambda_ = opti_res[1]\n                # NOTE: DEBUG\n                load_factor_solver.export_minimization_plots(\n                    phi_,\n                    lambda_,\n                    phi0,\n                    SIFs_controlled,\n                    SIFs_prescribed,\n                    self.s,\n                    t,\n                    dir_name,\n                )\n                # Add a new crack point\n                da_vec = self.da * np.array([np.cos(phi_), np.sin(phi_), 0])\n                crack_points.append(crack_points[-1] + da_vec)\n            else:\n                # Display a warning message\n                print(\"\u2502  Running in no propagation mode (set arbitrary results).\")\n                # Set arbitrary results\n                phi_ = 0\n                lambda_ = 1\n\n            print(\"\u2502  Results of the step\")\n            print(\n                f\"\u2502  \u2502  Crack propagation angle : {phi_:.3f} rad / {phi_ * 180 / np.pi:.3f}\u00b0\"\n            )\n            print(f\"\u2502  \u2502  Load factor             : {lambda_:.3g}\")\n            print(f\"\u2502  \u2502  New crack tip position  : {crack_points[-1]}\")\n\n            print(\"\u2502  Postprocess\")\n            # Scale the displacement field\n            u_scaled = u_controlled.copy()\n            u_scaled.x.array[:] = lambda_ * u_controlled.x.array + u_prescribed.x.array\n            u_scaled.name = \"Displacement\"\n            # Compute the reaction force\n            fimp = compute_measured_forces(self.domain, model, u_scaled, self)\n            uimp = compute_measured_displacement(self.domain, u_scaled, self)\n            # COmpute energies\n            elastic_energy = compute_elastic_energy(self.domain, model, u_scaled)\n            external_work = compute_external_work(self.domain, model, u_scaled)\n\n            print(\"\u2502  Export the results\")\n            # Export the elastic solution\n            export_function(u_scaled, t, dir_name)\n\n            # Store the results\n            res[\"t\"] = t\n            res[\"a\"] += self.da\n            res[\"phi\"] = phi_\n            res[\"lambda\"] = lambda_\n            res[\"xc_1\"] = crack_points[-1][0]\n            res[\"xc_2\"] = crack_points[-1][1]\n            res[\"xc_3\"] = crack_points[-1][2]\n            for comp, uimp_comp in enumerate(uimp):\n                res[f\"uimp_{comp + 1}\"] = uimp[comp]\n            for comp, fimp_comp in enumerate(fimp):\n                res[f\"fimp_{comp + 1}\"] = fimp[comp]\n            for sif_name in SIFs_controlled:\n                res[sif_name] = (\n                    lambda_ * SIFs_controlled[sif_name] + SIFs_prescribed[sif_name]\n                )\n            res[\"elastic_energy\"] = elastic_energy\n            res[\"fracture_dissipation\"] += self.da * self.Gc(np.array([phi_]))[0]\n            res[\"external_work\"] = external_work\n            # At first load step, also export the initial state\n            if t == 1:\n                res_init = res.copy()\n                for key in res_init:\n                    res_init[key] = 0.0\n                export_res_to_csv(res_init, dir_name / \"results.csv\")\n                del res_init\n            # Export the current results to csv\n            export_res_to_csv(res, dir_name / \"results.csv\")\n        print(\"\\nFinalize exports\")\n        # Group clean the results directory\n        clean_vtk_files(dir_name)\n        # Clean up\n        gmsh.finalize()\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.E","title":"<code>E</code>  <code>instance-attribute</code>","text":"<p>E (float): Young's modulus of the material.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.Nt","title":"<code>Nt</code>  <code>instance-attribute</code>","text":"<p>Nt (int): Number of crack increment.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.assumption_2D","title":"<code>assumption_2D</code>  <code>instance-attribute</code>","text":"<p>assumption_2D (str): Assumption for 2D elasticity (e.g., 'plane stress', 'plane strain').</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.criterion","title":"<code>criterion = 'gmerr'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>criterion (Optional[str]): Criterion for crack propagation, defaults to \"gmerr\".</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.da","title":"<code>da</code>  <code>instance-attribute</code>","text":"<p>da (float): Crack increment length.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.l0","title":"<code>l0 = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>l0 (Optional[float]): Initial load factor, defaults to 0.0.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.name","title":"<code>name = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>name (Optional[str]): Name of the simulation used to name the results directory.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.no_meshing","title":"<code>no_meshing = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>no_meshing (Optional[bool]): Flag to skip mesh generation when a mesh has already been created.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.no_propagation","title":"<code>no_propagation = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>no_propagation (Optional[bool]): Flag to only run skip the crack propagation phase.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.nu","title":"<code>nu</code>  <code>instance-attribute</code>","text":"<p>nu (float): Poisson's ratio of the material.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.pars","title":"<code>pars</code>  <code>instance-attribute</code>","text":"<p>pars (dict): User-defined parameters passed to user-defined functions.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.phi0","title":"<code>phi0 = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>phi0 (Optional[float]): Initial crack propagation angle, defaults to 0.0.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.s","title":"<code>s = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>s (Optional[float]): Internal length associated with T-stress, defaults to 0.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.sif_method","title":"<code>sif_method = 'I-integral'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>sif_method (Optional[str]): Method for computing Stress Intensity Factors (SIFs), defaults to \"I-integral\".</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.xc0","title":"<code>xc0</code>  <code>instance-attribute</code>","text":"<p>xc0 (np.array): Initial crack tip coordinates.</p>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.Gc","title":"<code>Gc(phi)</code>  <code>abstractmethod</code>","text":"<p>Define the critical energy release rate.</p> <p>To account for material anisotropy, the critical energy release rate can depend on the crack orientation $\\varphi$</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>ndarray</code> <p>Crack angle.</p> required <p>Returns:</p> Type Description <code>float | ndarray</code> <p>np.ndarray: Value of the critical energy release rate.</p> Note <p>The intput and output should be arrays for practical details in the minimization of the load factor.</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>@abstractmethod\ndef Gc(self, phi: float | np.ndarray) -&gt; float | np.ndarray:\n    \"\"\"Define the critical energy release rate.\n\n    To account for material anisotropy, the critical energy release rate can depend on the crack orientation $\\\\varphi$\n\n    Args:\n        phi (np.ndarray): Crack angle.\n\n    Returns:\n        np.ndarray: Value of the critical energy release rate.\n\n    Note:\n        The intput and output should be arrays for practical details in the minimization of the load factor.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.define_controlled_body_forces","title":"<code>define_controlled_body_forces()</code>","text":"<p>Define the controlled body forces that are affected by the load factor.</p> <p>Returns:</p> Type Description <code>List[BodyForce]</code> <p>List[BodyForce]: List of BodyForce (f_imp) where f_imp is the force vector.</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def define_controlled_body_forces(self) -&gt; List[BodyForce]:\n    \"\"\"Define the controlled body forces that are affected by the load factor.\n\n    Returns:\n        List[BodyForce]: List of BodyForce (f_imp) where f_imp is the force vector.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.define_controlled_displacements","title":"<code>define_controlled_displacements()</code>","text":"<p>Define the displacement boundary conditions controlled by the load factor.</p> <p>Returns:</p> Type Description <code>List[DisplacementBC]</code> <p>List[DisplacementBC]: List of DisplacementBC(boundary_id, u_imp) where boundary_id is the boundary id (int number) in GMSH, and u_imp is the displacement vector (componements can be nan to let it free).</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def define_controlled_displacements(self) -&gt; List[DisplacementBC]:\n    \"\"\"Define the displacement boundary conditions controlled by the load factor.\n\n    Returns:\n        List[DisplacementBC]: List of DisplacementBC(boundary_id, u_imp) where boundary_id is the boundary id (int number) in GMSH, and u_imp is the displacement vector (componements can be nan to let it free).\n    \"\"\"\n    return []\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.define_controlled_forces","title":"<code>define_controlled_forces()</code>","text":"<p>Define the force boundary conditions controlled by the load factor.</p> <p>Returns:</p> Type Description <code>List[ForceBC]</code> <p>List[ForceBC]: List of ForceBC(boundary_id, f_imp) where boundary_id is the boundary id (int number) in GMSH, and f_imp is the force vector.</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def define_controlled_forces(self) -&gt; List[ForceBC]:\n    \"\"\"Define the force boundary conditions controlled by the load factor.\n\n    Returns:\n        List[ForceBC]: List of ForceBC(boundary_id, f_imp) where boundary_id is the boundary id (int number) in GMSH, and f_imp is the force vector.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.define_locked_points","title":"<code>define_locked_points()</code>","text":"<p>Define the list of locked points.</p> <p>Returns:</p> Type Description <code>List[List[float]]</code> <p>List[List[float]]: A list of points (list) coordinates.</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def define_locked_points(self) -&gt; List[List[float]]:\n    \"\"\"Define the list of locked points.\n\n    Returns:\n        List[List[float]]: A list of points (list) coordinates.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.define_nodal_displacements","title":"<code>define_nodal_displacements()</code>","text":"<p>Define a list of imposed nodal displacements.</p> <p>Returns:</p> Type Description <code>List[NodalDisplacement]</code> <p>List[NodalDisplacements]: A list of NodalDisplacement.</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def define_nodal_displacements(self) -&gt; List[NodalDisplacement]:\n    \"\"\"Define a list of imposed nodal displacements.\n\n    Returns:\n        List[NodalDisplacements]: A list of NodalDisplacement.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.define_prescribed_body_forces","title":"<code>define_prescribed_body_forces()</code>","text":"<p>Define the prescribed body forces that are not affected by the load factor.</p> <p>Returns:</p> Type Description <code>List[BodyForce]</code> <p>List[BodyForce]: List of BodyForce (f_imp) where f_imp is the force vector.</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def define_prescribed_body_forces(self) -&gt; List[BodyForce]:\n    \"\"\"Define the prescribed body forces that are not affected by the load factor.\n\n    Returns:\n        List[BodyForce]: List of BodyForce (f_imp) where f_imp is the force vector.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.define_prescribed_displacements","title":"<code>define_prescribed_displacements()</code>","text":"<p>Define the prescribed displacement boundary conditions that are not affected by the load factor.</p> <p>Returns:</p> Type Description <code>List[DisplacementBC]</code> <p>List[DisplacementBC]: List of DisplacementBC(boundary_id, u_imp) where boundary_id is the boundary id (int number) in GMSH, and u_imp is the displacement vector (componements can be nan to let it free).</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def define_prescribed_displacements(self) -&gt; List[DisplacementBC]:\n    \"\"\"Define the prescribed displacement boundary conditions that are not affected by the load factor.\n\n    Returns:\n        List[DisplacementBC]: List of DisplacementBC(boundary_id, u_imp) where boundary_id is the boundary id (int number) in GMSH, and u_imp is the displacement vector (componements can be nan to let it free).\n    \"\"\"\n    return []\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.define_prescribed_forces","title":"<code>define_prescribed_forces()</code>","text":"<p>Define the prescribed force boundary conditions that are not affected by the load factor.</p> <p>Returns:</p> Type Description <code>List[ForceBC]</code> <p>List[ForceBC]: List of ForceBC(boundary_id, f_imp) where boundary_id is the boundary id (int number) in GMSH, and f_imp is the force vector.</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def define_prescribed_forces(self) -&gt; List[ForceBC]:\n    \"\"\"Define the prescribed force boundary conditions that are not affected by the load factor.\n\n    Returns:\n        List[ForceBC]: List of ForceBC(boundary_id, f_imp) where boundary_id is the boundary id (int number) in GMSH, and f_imp is the force vector.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.locate_measured_displacement","title":"<code>locate_measured_displacement()</code>  <code>abstractmethod</code>","text":"<p>Define the point where the displacement is measured.</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List[float]</code> <p>Coordinate of the point where the displacement is measured</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>@abstractmethod\ndef locate_measured_displacement(self) -&gt; List[float]:\n    \"\"\"Define the point where the displacement is measured.\n\n    Returns:\n        List: Coordinate of the point where the displacement is measured\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.locate_measured_forces","title":"<code>locate_measured_forces()</code>  <code>abstractmethod</code>","text":"<p>Define the boundary where the reaction force are measured.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Identifier (id) of the boundary in GMSH.</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>@abstractmethod\ndef locate_measured_forces(self) -&gt; int:\n    \"\"\"Define the boundary where the reaction force are measured.\n\n    Returns:\n        int: Identifier (id) of the boundary in GMSH.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.run","title":"<code>run()</code>","text":"<p>Executes the crack propagation simulation workflow.</p> <p>This method manages the entire simulation process, including:</p> <ul> <li>Initializing the GMSH environment and results directory.</li> <li>Generating the mesh for the cracked domain (unless <code>no_meshing</code> is True).</li> <li>Applying boundary conditions (displacements, forces, body forces, locked points, etc.).</li> <li>Solving the elastic problem for both controlled and prescribed boundary conditions.</li> <li>Computing Stress Intensity Factors (SIFs) using the specified method.</li> <li>Determining the crack propagation angle and load factor.</li> <li>Post-processing results, including computing energies, reaction forces, and displacements.</li> <li>Exporting results to VTK and CSV formats.</li> </ul> <p>The simulation runs for <code>self.Nt</code> load steps, updating the crack tip position and boundary conditions at each step. Results are stored in a dictionary and exported to the results directory.</p> <p>Steps:</p> <ol> <li>Initialize GMSH and create the results directory.</li> <li>For each load step:<ol> <li>Generate the mesh (if <code>no_meshing</code> is False).</li> <li>Define and apply boundary conditions.</li> <li>Solve the elastic problem for controlled and prescribed boundary conditions.</li> <li>Compute SIFs for both controlled and prescribed problems.</li> <li>Determine the crack propagation angle and load factor.</li> <li>Post-process results (e.g., compute energies, reaction forces, displacements). g. Export results to VTK and CSV files.</li> </ol> </li> <li>Clean up and finalize the simulation.</li> </ol> Note <ul> <li>The <code>no_meshing</code> flag can be set to skip mesh generation if a mesh already exists.</li> <li>The <code>no_propagation</code> flag can be set to skip crack propagation and use arbitrary load factor/crack propagation angle.</li> </ul> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def run(self):\n    \"\"\"Executes the crack propagation simulation workflow.\n\n    This method manages the entire simulation process, including:\n\n    - Initializing the GMSH environment and results directory.\n    - Generating the mesh for the cracked domain (unless `no_meshing` is True).\n    - Applying boundary conditions (displacements, forces, body forces, locked points, etc.).\n    - Solving the elastic problem for both controlled and prescribed boundary conditions.\n    - Computing Stress Intensity Factors (SIFs) using the specified method.\n    - Determining the crack propagation angle and load factor.\n    - Post-processing results, including computing energies, reaction forces, and displacements.\n    - Exporting results to VTK and CSV formats.\n\n    The simulation runs for `self.Nt` load steps, updating the crack tip position and\n    boundary conditions at each step. Results are stored in a dictionary and exported\n    to the results directory.\n\n    Steps:\n\n    1. Initialize GMSH and create the results directory.\n    2. For each load step:\n        1. Generate the mesh (if `no_meshing` is False).\n        2. Define and apply boundary conditions.\n        3. Solve the elastic problem for controlled and prescribed boundary conditions.\n        4. Compute SIFs for both controlled and prescribed problems.\n        5. Determine the crack propagation angle and load factor.\n        6. Post-process results (e.g., compute energies, reaction forces, displacements).\n        g. Export results to VTK and CSV files.\n    3. Clean up and finalize the simulation.\n\n    Note:\n        - The `no_meshing` flag can be set to skip mesh generation if a mesh already exists.\n        - The `no_propagation` flag can be set to skip crack propagation and use arbitrary load factor/crack propagation angle.\n    \"\"\"\n    # Initialize GMSH\n    gmsh.initialize()\n    gmsh.option.setNumber(\"General.Terminal\", 0)  # Disable terminal output\n    gmsh.option.setNumber(\"Mesh.Algorithm\", 5)\n    # 1: meshadapt; 5: delaunay, 6: frontal-delaunay\n\n    # Initialize export directory\n    dir_name = Path(\"results_\" + self.name)\n    dir_name.mkdir(parents=True, exist_ok=True)\n\n    # Get the elastic parameters\n    ela_pars = {\n        \"E\": self.E,\n        \"nu\": self.nu,\n        \"2D_assumption\": self.assumption_2D,\n    }\n    # Initialize the crack points\n    crack_points = [self.xc0]\n    # Initialize results storage\n    res = {\n        \"t\": 0,\n        \"a\": 0,\n        \"phi\": self.phi0,\n        \"lambda\": self.l0,\n        \"xc_1\": crack_points[-1][0],\n        \"xc_2\": crack_points[-1][1],\n        \"xc_3\": crack_points[-1][2],\n        \"uimp_1\": 0.0,\n        \"uimp_2\": 0.0,\n        \"fimp_1\": 0.0,\n        \"fimp_2\": 0.0,\n        \"KI\": 0.0,\n        \"KII\": 0.0,\n        \"T\": 0.0,\n        \"elastic_energy\": 0.0,\n        \"fracture_dissipation\": 0.0,\n        \"external_work\": 0.0,\n    }\n\n    for t in range(1, self.Nt + 1):\n        print(f\"\\nLOAD STEP {t}\")\n        # Get current crack properties\n        phi0 = res[\"phi\"]\n\n        # Run the user defined load step initialization\n        self.user_load_step_initialization(res)\n\n        # Generate the mesh\n        if not self.no_meshing:\n            print(\"\u2502  Meshing the cracked domain\")\n            gmsh_model = self.generate_mesh(crack_points)\n        else:\n            print(\"\u2502  Skip meshing (no_meshing = True)\")\n\n        # Get the controlled boundary conditions\n        controlled_bcs = BoundaryConditions(\n            displacement_bcs=self.define_controlled_displacements(),\n            force_bcs=self.define_controlled_forces(),\n            body_forces=self.define_controlled_body_forces(),\n            locked_points=self.define_locked_points(),\n            nodal_displacements=self.define_nodal_displacements(),\n        )\n\n        # Get the controlled boundary conditions\n        prescribed_bcs = BoundaryConditions(\n            displacement_bcs=self.define_prescribed_displacements(),\n            force_bcs=self.define_prescribed_forces(),\n            body_forces=self.define_prescribed_body_forces(),\n            locked_points=self.define_locked_points(),\n            nodal_displacements=self.define_nodal_displacements(),\n        )\n\n        # Define the domain\n        if not self.no_meshing:\n            self.domain = Domain(gmsh_model)\n\n        # Define an elastic model\n        model = ElasticModel(ela_pars, self.domain)\n        if t == 1:\n            export_heterogeneous_parameters(model, ela_pars, dir_name)\n\n        print(\"\u2502  Solve the controlled elastic problem with FEM\")\n        # Solve the controlled elastic problem\n        u_controlled = solve_elastic_problem(self.domain, model, controlled_bcs)\n\n        print(f\"\u2502  Compute the SIFs for the controlled problem ({self.sif_method})\")\n        # Compute the SIFs for the controlled problem\n        SIFs_controlled = compute_SIFs(\n            self.domain,\n            model,\n            u_controlled,\n            crack_points[-1],\n            phi0,\n            self.R_int,\n            self.R_ext,\n            self.sif_method,\n        )\n\n        # Tackle the prescribed problem\n        if not prescribed_bcs.is_null():\n            print(\"\u2502  Solve the prescribed elastic problem with FEM\")\n            # Solve the prescribed elastic problem\n            u_prescribed = solve_elastic_problem(self.domain, model, prescribed_bcs)\n            # Compute the SIFs for the prescribed problem\n            SIFs_prescribed = compute_SIFs(\n                self.domain,\n                model,\n                u_prescribed,\n                crack_points[-1],\n                phi0,\n                self.R_int,\n                self.R_ext,\n                self.sif_method,\n            )\n        else:\n            # Set the prescribed displacement to 0\n            u_prescribed = u_controlled.copy()\n            u_prescribed.x.array[:] = 0.0\n            # Set the SIFs to 0\n            SIFs_prescribed = {key: 0.0 for key in SIFs_controlled}\n            print(\"\u2502  No prescribed BCs\")\n\n        # Compute the load factor and crack angle.\n        print(\"\u2502  Determination of propagation angle and load factor\")\n        if not self.no_propagation:\n            load_factor_solver = LoadFactorSolver(model, self.Gc, crack_points[-1])\n            opti_res = load_factor_solver.solve(\n                phi0, SIFs_controlled, SIFs_prescribed, self.s\n            )\n            # Get the results\n            phi_ = opti_res[0]\n            lambda_ = opti_res[1]\n            # NOTE: DEBUG\n            load_factor_solver.export_minimization_plots(\n                phi_,\n                lambda_,\n                phi0,\n                SIFs_controlled,\n                SIFs_prescribed,\n                self.s,\n                t,\n                dir_name,\n            )\n            # Add a new crack point\n            da_vec = self.da * np.array([np.cos(phi_), np.sin(phi_), 0])\n            crack_points.append(crack_points[-1] + da_vec)\n        else:\n            # Display a warning message\n            print(\"\u2502  Running in no propagation mode (set arbitrary results).\")\n            # Set arbitrary results\n            phi_ = 0\n            lambda_ = 1\n\n        print(\"\u2502  Results of the step\")\n        print(\n            f\"\u2502  \u2502  Crack propagation angle : {phi_:.3f} rad / {phi_ * 180 / np.pi:.3f}\u00b0\"\n        )\n        print(f\"\u2502  \u2502  Load factor             : {lambda_:.3g}\")\n        print(f\"\u2502  \u2502  New crack tip position  : {crack_points[-1]}\")\n\n        print(\"\u2502  Postprocess\")\n        # Scale the displacement field\n        u_scaled = u_controlled.copy()\n        u_scaled.x.array[:] = lambda_ * u_controlled.x.array + u_prescribed.x.array\n        u_scaled.name = \"Displacement\"\n        # Compute the reaction force\n        fimp = compute_measured_forces(self.domain, model, u_scaled, self)\n        uimp = compute_measured_displacement(self.domain, u_scaled, self)\n        # COmpute energies\n        elastic_energy = compute_elastic_energy(self.domain, model, u_scaled)\n        external_work = compute_external_work(self.domain, model, u_scaled)\n\n        print(\"\u2502  Export the results\")\n        # Export the elastic solution\n        export_function(u_scaled, t, dir_name)\n\n        # Store the results\n        res[\"t\"] = t\n        res[\"a\"] += self.da\n        res[\"phi\"] = phi_\n        res[\"lambda\"] = lambda_\n        res[\"xc_1\"] = crack_points[-1][0]\n        res[\"xc_2\"] = crack_points[-1][1]\n        res[\"xc_3\"] = crack_points[-1][2]\n        for comp, uimp_comp in enumerate(uimp):\n            res[f\"uimp_{comp + 1}\"] = uimp[comp]\n        for comp, fimp_comp in enumerate(fimp):\n            res[f\"fimp_{comp + 1}\"] = fimp[comp]\n        for sif_name in SIFs_controlled:\n            res[sif_name] = (\n                lambda_ * SIFs_controlled[sif_name] + SIFs_prescribed[sif_name]\n            )\n        res[\"elastic_energy\"] = elastic_energy\n        res[\"fracture_dissipation\"] += self.da * self.Gc(np.array([phi_]))[0]\n        res[\"external_work\"] = external_work\n        # At first load step, also export the initial state\n        if t == 1:\n            res_init = res.copy()\n            for key in res_init:\n                res_init[key] = 0.0\n            export_res_to_csv(res_init, dir_name / \"results.csv\")\n            del res_init\n        # Export the current results to csv\n        export_res_to_csv(res, dir_name / \"results.csv\")\n    print(\"\\nFinalize exports\")\n    # Group clean the results directory\n    clean_vtk_files(dir_name)\n    # Clean up\n    gmsh.finalize()\n</code></pre>"},{"location":"API/gcrack/#gcrack.gcrack.GCrackBase.user_load_step_initialization","title":"<code>user_load_step_initialization(res)</code>","text":"<p>User-defined load step initialization.</p> <p>Customize load step initialization using results from the previous step. This can include creating custom variables for boundary conditions. This function is called at the very beginning of the load step.</p> Source code in <code>src/gcrack/gcrack.py</code> <pre><code>def user_load_step_initialization(self, res: dict) -&gt; None:\n    \"\"\"User-defined load step initialization.\n\n    Customize load step initialization using results from the previous step.\n    This can include creating custom variables for boundary conditions.\n    This function is called at the very beginning of the load step.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API/models/","title":"Models","text":"<p>Module for defining the elastic model.</p> <p>This module provides the <code>ElasticModel</code> class, which encapsulates the material properties and mechanical behavior of elastic materials. It supports both homogeneous and heterogeneous material properties, as well as different 2D assumptions (plane stress, plane strain, anti-plane). The class also provides methods for computing displacement gradients, strain tensors, stress tensors, and elastic energy.</p>"},{"location":"API/models/#gcrack.models.ElasticModel","title":"<code>ElasticModel</code>","text":"<p>Class for defining an elastic material model in finite element simulations.</p> <p>This class encapsulates the material properties and mechanical behavior of elastic materials. It supports both homogeneous and heterogeneous material properties, as well as different 2D assumptions (plane stress, plane strain, anti-plane). The class provides methods for computing displacement gradients, strain tensors, stress tensors, and elastic energy.</p> <p>Attributes:</p> Name Type Description <code>E</code> <code>float or Function</code> <p>Young's modulus.</p> <code>nu</code> <code>float or Function</code> <p>Poisson's ratio.</p> <code>la</code> <code>float or Function</code> <p>Lame coefficient lambda.</p> <code>mu</code> <code>float or Function</code> <p>Lame coefficient mu.</p> <code>assumption</code> <code>str</code> <p>2D assumption for the simulation (e.g., \"plane_stress\", \"plane_strain\", \"anti_plane\").</p> <code>Ep</code> <code>float</code> <p>Plane strain modulus.</p> <code>ka</code> <code>float</code> <p>Kolosov constant.</p> Source code in <code>src/gcrack/models.py</code> <pre><code>class ElasticModel:\n    \"\"\"Class for defining an elastic material model in finite element simulations.\n\n    This class encapsulates the material properties and mechanical behavior of elastic materials.\n    It supports both homogeneous and heterogeneous material properties, as well as different 2D assumptions (plane stress, plane strain, anti-plane).\n    The class provides methods for computing displacement gradients, strain tensors, stress tensors, and elastic energy.\n\n    Attributes:\n        E (float or dolfinx.Function): Young's modulus.\n        nu (float or dolfinx.Function): Poisson's ratio.\n        la (float or dolfinx.Function): Lame coefficient lambda.\n        mu (float or dolfinx.Function): Lame coefficient mu.\n        assumption (str): 2D assumption for the simulation (e.g., \"plane_stress\", \"plane_strain\", \"anti_plane\").\n        Ep (float): Plane strain modulus.\n        ka (float): Kolosov constant.\n    \"\"\"\n\n    def __init__(self, pars, domain=None):\n        \"\"\"Initializes the ElasticModel.\n\n        Args:\n            pars (dict): Dictionary containing parameters of the material model.\n                Required keys: \"E\" (Young's modulus), \"nu\" (Poisson's ratio), and \"2D_assumption\" (2D assumption).\n            domain (fragma.Domain.domain, optional): Domain object, it is only used to initialize heterogeneous properties.\n                Defaults to None.\n        \"\"\"\n        # Display warnings if necessary\n        self.displays_warnings(pars)\n        # Define a function space for parameter parsing\n        V_par = fem.functionspace(domain.mesh, (\"DG\", 0))\n        # Get elastic parameters\n        self.E, self.E_func = parse_expression(pars[\"E\"], V_par, export_func=True)\n        self.nu, self.nu_func = parse_expression(pars[\"nu\"], V_par, export_func=True)\n        # Compute Lame coefficient\n        self.la = self.E * self.nu / ((1 + self.nu) * (1 - 2 * self.nu))\n        self.mu = self.E / (2 * (1 + self.nu))\n        self.mu_func = lambda xx: self.E_func(xx) / (2 * (1 + self.nu_func(xx)))\n        # Check the 2D assumption\n        if domain is not None and domain.dim == 2:\n            self.assumption = pars[\"2D_assumption\"]\n            match self.assumption:\n                case \"plane_stress\" | \"anti_plane\":\n                    self.Ep = self.E\n                    self.Ep_func = lambda xx: self.E_func(xx)\n                    self.ka = (3 - self.nu) / (1 + self.nu)\n                    self.ka_func = lambda xx: (3 - self.nu_func(xx)) / (\n                        1 + self.nu_func(xx)\n                    )\n                    if self.assumption == \"anti_plane\":\n                        print(\n                            \"\u2502  For anti-plane, we assume plane stress for SIF calculations.\"\n                        )\n                case \"plane_strain\":\n                    self.Ep = self.E / (1 - self.nu**2)\n                    self.Ep_func = lambda xx: self.E_func(xx) / (\n                        1 - self.nu_func(xx) ** 2\n                    )\n                    self.ka = 3 - 4 * self.nu\n                    self.ka_func = lambda xx: 3 - 4 * self.nu_func(xx)\n                case _:\n                    raise ValueError(\n                        f'The 2D assumption \"{self.assumption}\" is unknown.'\n                    )\n\n    def displays_warnings(self, pars: dict):\n        \"\"\"Check the parameters and display warnings if necessary.\n\n        Args:\n            pars (dict): Dictionary of the model parameters.\n        \"\"\"\n        # Check potential triggers\n        heterogeneous_properties = isinstance(pars[\"E\"], str) or isinstance(\n            pars[\"nu\"], str\n        )\n        # Display the warning in crack of heterogeneous properties\n        if heterogeneous_properties:\n            print(\"\"\"\u2502  WARNING: USE OF HETEROGENEOUS ELASTIC PROPERTIES\n\u2502  \u2502  A string has been passed for the elastic properties (E or nu).\n\u2502  \u2502  It means the simulation includes heterogeneous elastic properties.\n\u2502  \u2502  Note that, when calculating the SIFs, the elastic properties are assumed to be:\n\u2502  \u2502      (1) homogeneous, and\n\u2502  \u2502      (2) equal to the elastic properties at the crack tip.\n\u2502  \u2502  The elastic properties variations must be negligible or null in the pacman.\n\u2502  \u2502  If the elastic properties  are constant, use floats to disable this message.\"\"\")\n\n    def u_to_3D(self, u: fem.Function) -&gt; ufl.classes.Expr:\n        \"\"\"Converts a 2D displacement field to its 3D version.\n\n        The conversion depends on the 2D assumption (plane stress, plane strain, or anti-plane).\n\n        Args:\n            u (fem.Function): FEM function of the displacement field.\n\n        Returns:\n            ufl.classes.Expr: Displacement in 3D.\n        \"\"\"\n        if self.assumption.startswith(\"plane\"):\n            return ufl.as_vector([u[0], u[1], 0])\n        elif self.assumption == \"anti_plane\":\n            return ufl.as_vector([0.0, 0.0, u[0]])\n        else:\n            raise ValueError(f\"Unknown 2D assumption: {self.assumption}.\")\n\n    def grad_u(self, u: fem.Function) -&gt; ufl.classes.Expr:\n        \"\"\"Computes the gradient of the displacement field.\n\n        Args:\n            u (fem.Function): FEM function of the displacement field.\n\n        Returns:\n            ufl.classes.Expr: Gradient of the displacement field in 3D.\n        \"\"\"\n        # Convert the displacement to 3D\n        u3D = self.u_to_3D(u)\n        # Compute the 2D gradient of the field\n        g_u3D = ufl.grad(u3D)\n        # Construct the strain tensor\n        match self.assumption:\n            case \"plane_strain\":\n                grad_u3D = ufl.as_tensor(\n                    [\n                        [g_u3D[0, 0], g_u3D[0, 1], 0],\n                        [g_u3D[1, 0], g_u3D[1, 1], 0],\n                        [0, 0, 0],\n                    ]\n                )\n            case \"plane_stress\":\n                eps_zz = -self.nu / (1 - self.nu) * (g_u3D[0, 0] + g_u3D[1, 1])\n                grad_u3D = ufl.as_tensor(\n                    [\n                        [g_u3D[0, 0], g_u3D[0, 1], 0],\n                        [g_u3D[1, 0], g_u3D[1, 1], 0],\n                        [0, 0, eps_zz],\n                    ]\n                )\n            case \"anti_plane\":\n                grad_u3D = ufl.as_tensor(\n                    [\n                        [0, 0, 0],\n                        [0, 0, 0],\n                        [g_u3D[2, 0], g_u3D[2, 1], 0],\n                    ]\n                )\n        # Return the gradient\n        return grad_u3D\n\n    def eps(self, u: fem.Function) -&gt; ufl.classes.Expr:\n        \"\"\"Computes the strain tensor.\n\n        Args:\n            u (fem.Function): FEM function of the displacement field.\n\n        Returns:\n            ufl.classes.Expr: Strain tensor.\n        \"\"\"\n        # Symmetrize the gradient\n        return ufl.sym(self.grad_u(u))\n\n    def sig(self, u: fem.Function) -&gt; ufl.classes.Expr:\n        \"\"\"Computes the stress tensor.\n\n        Args:\n            u (fem.Function): FEM function of the displacement field.\n\n        Returns:\n            ufl.classes.Expr: Stress tensor.\n        \"\"\"\n        # Get elastic parameters\n        mu, la = self.mu, self.la\n        # Compute the stress\n        eps = self.eps(u)\n        return la * ufl.tr(eps) * ufl.Identity(3) + 2 * mu * eps\n\n    def elastic_energy(self, u, domain):\n        \"\"\"Computes the elastic energy.\n\n        Args:\n            u (fem.Function): FEM function of the displacement field.\n            domain (fragma.Domain.domain): The domain object representing the computational domain.\n\n        Returns:\n            ufl.classes.Expr: Elastic energy.\n        \"\"\"\n        # Get the integration measure\n        dx = ufl.Measure(\"dx\", domain=domain.mesh, metadata={\"quadrature_degree\": 6})\n        # Compute the stress\n        sig = self.sig(u)\n        # Compute the strain\n        eps = self.eps(u)\n        # Define the total energy\n        return 1 / 2 * ufl.inner(sig, eps) * dx\n</code></pre>"},{"location":"API/models/#gcrack.models.ElasticModel.__init__","title":"<code>__init__(pars, domain=None)</code>","text":"<p>Initializes the ElasticModel.</p> <p>Parameters:</p> Name Type Description Default <code>pars</code> <code>dict</code> <p>Dictionary containing parameters of the material model. Required keys: \"E\" (Young's modulus), \"nu\" (Poisson's ratio), and \"2D_assumption\" (2D assumption).</p> required <code>domain</code> <code>domain</code> <p>Domain object, it is only used to initialize heterogeneous properties. Defaults to None.</p> <code>None</code> Source code in <code>src/gcrack/models.py</code> <pre><code>def __init__(self, pars, domain=None):\n    \"\"\"Initializes the ElasticModel.\n\n    Args:\n        pars (dict): Dictionary containing parameters of the material model.\n            Required keys: \"E\" (Young's modulus), \"nu\" (Poisson's ratio), and \"2D_assumption\" (2D assumption).\n        domain (fragma.Domain.domain, optional): Domain object, it is only used to initialize heterogeneous properties.\n            Defaults to None.\n    \"\"\"\n    # Display warnings if necessary\n    self.displays_warnings(pars)\n    # Define a function space for parameter parsing\n    V_par = fem.functionspace(domain.mesh, (\"DG\", 0))\n    # Get elastic parameters\n    self.E, self.E_func = parse_expression(pars[\"E\"], V_par, export_func=True)\n    self.nu, self.nu_func = parse_expression(pars[\"nu\"], V_par, export_func=True)\n    # Compute Lame coefficient\n    self.la = self.E * self.nu / ((1 + self.nu) * (1 - 2 * self.nu))\n    self.mu = self.E / (2 * (1 + self.nu))\n    self.mu_func = lambda xx: self.E_func(xx) / (2 * (1 + self.nu_func(xx)))\n    # Check the 2D assumption\n    if domain is not None and domain.dim == 2:\n        self.assumption = pars[\"2D_assumption\"]\n        match self.assumption:\n            case \"plane_stress\" | \"anti_plane\":\n                self.Ep = self.E\n                self.Ep_func = lambda xx: self.E_func(xx)\n                self.ka = (3 - self.nu) / (1 + self.nu)\n                self.ka_func = lambda xx: (3 - self.nu_func(xx)) / (\n                    1 + self.nu_func(xx)\n                )\n                if self.assumption == \"anti_plane\":\n                    print(\n                        \"\u2502  For anti-plane, we assume plane stress for SIF calculations.\"\n                    )\n            case \"plane_strain\":\n                self.Ep = self.E / (1 - self.nu**2)\n                self.Ep_func = lambda xx: self.E_func(xx) / (\n                    1 - self.nu_func(xx) ** 2\n                )\n                self.ka = 3 - 4 * self.nu\n                self.ka_func = lambda xx: 3 - 4 * self.nu_func(xx)\n            case _:\n                raise ValueError(\n                    f'The 2D assumption \"{self.assumption}\" is unknown.'\n                )\n</code></pre>"},{"location":"API/models/#gcrack.models.ElasticModel.displays_warnings","title":"<code>displays_warnings(pars)</code>","text":"<p>Check the parameters and display warnings if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>pars</code> <code>dict</code> <p>Dictionary of the model parameters.</p> required Source code in <code>src/gcrack/models.py</code> <pre><code>    def displays_warnings(self, pars: dict):\n        \"\"\"Check the parameters and display warnings if necessary.\n\n        Args:\n            pars (dict): Dictionary of the model parameters.\n        \"\"\"\n        # Check potential triggers\n        heterogeneous_properties = isinstance(pars[\"E\"], str) or isinstance(\n            pars[\"nu\"], str\n        )\n        # Display the warning in crack of heterogeneous properties\n        if heterogeneous_properties:\n            print(\"\"\"\u2502  WARNING: USE OF HETEROGENEOUS ELASTIC PROPERTIES\n\u2502  \u2502  A string has been passed for the elastic properties (E or nu).\n\u2502  \u2502  It means the simulation includes heterogeneous elastic properties.\n\u2502  \u2502  Note that, when calculating the SIFs, the elastic properties are assumed to be:\n\u2502  \u2502      (1) homogeneous, and\n\u2502  \u2502      (2) equal to the elastic properties at the crack tip.\n\u2502  \u2502  The elastic properties variations must be negligible or null in the pacman.\n\u2502  \u2502  If the elastic properties  are constant, use floats to disable this message.\"\"\")\n</code></pre>"},{"location":"API/models/#gcrack.models.ElasticModel.elastic_energy","title":"<code>elastic_energy(u, domain)</code>","text":"<p>Computes the elastic energy.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Function</code> <p>FEM function of the displacement field.</p> required <code>domain</code> <code>domain</code> <p>The domain object representing the computational domain.</p> required <p>Returns:</p> Type Description <p>ufl.classes.Expr: Elastic energy.</p> Source code in <code>src/gcrack/models.py</code> <pre><code>def elastic_energy(self, u, domain):\n    \"\"\"Computes the elastic energy.\n\n    Args:\n        u (fem.Function): FEM function of the displacement field.\n        domain (fragma.Domain.domain): The domain object representing the computational domain.\n\n    Returns:\n        ufl.classes.Expr: Elastic energy.\n    \"\"\"\n    # Get the integration measure\n    dx = ufl.Measure(\"dx\", domain=domain.mesh, metadata={\"quadrature_degree\": 6})\n    # Compute the stress\n    sig = self.sig(u)\n    # Compute the strain\n    eps = self.eps(u)\n    # Define the total energy\n    return 1 / 2 * ufl.inner(sig, eps) * dx\n</code></pre>"},{"location":"API/models/#gcrack.models.ElasticModel.eps","title":"<code>eps(u)</code>","text":"<p>Computes the strain tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Function</code> <p>FEM function of the displacement field.</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>ufl.classes.Expr: Strain tensor.</p> Source code in <code>src/gcrack/models.py</code> <pre><code>def eps(self, u: fem.Function) -&gt; ufl.classes.Expr:\n    \"\"\"Computes the strain tensor.\n\n    Args:\n        u (fem.Function): FEM function of the displacement field.\n\n    Returns:\n        ufl.classes.Expr: Strain tensor.\n    \"\"\"\n    # Symmetrize the gradient\n    return ufl.sym(self.grad_u(u))\n</code></pre>"},{"location":"API/models/#gcrack.models.ElasticModel.grad_u","title":"<code>grad_u(u)</code>","text":"<p>Computes the gradient of the displacement field.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Function</code> <p>FEM function of the displacement field.</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>ufl.classes.Expr: Gradient of the displacement field in 3D.</p> Source code in <code>src/gcrack/models.py</code> <pre><code>def grad_u(self, u: fem.Function) -&gt; ufl.classes.Expr:\n    \"\"\"Computes the gradient of the displacement field.\n\n    Args:\n        u (fem.Function): FEM function of the displacement field.\n\n    Returns:\n        ufl.classes.Expr: Gradient of the displacement field in 3D.\n    \"\"\"\n    # Convert the displacement to 3D\n    u3D = self.u_to_3D(u)\n    # Compute the 2D gradient of the field\n    g_u3D = ufl.grad(u3D)\n    # Construct the strain tensor\n    match self.assumption:\n        case \"plane_strain\":\n            grad_u3D = ufl.as_tensor(\n                [\n                    [g_u3D[0, 0], g_u3D[0, 1], 0],\n                    [g_u3D[1, 0], g_u3D[1, 1], 0],\n                    [0, 0, 0],\n                ]\n            )\n        case \"plane_stress\":\n            eps_zz = -self.nu / (1 - self.nu) * (g_u3D[0, 0] + g_u3D[1, 1])\n            grad_u3D = ufl.as_tensor(\n                [\n                    [g_u3D[0, 0], g_u3D[0, 1], 0],\n                    [g_u3D[1, 0], g_u3D[1, 1], 0],\n                    [0, 0, eps_zz],\n                ]\n            )\n        case \"anti_plane\":\n            grad_u3D = ufl.as_tensor(\n                [\n                    [0, 0, 0],\n                    [0, 0, 0],\n                    [g_u3D[2, 0], g_u3D[2, 1], 0],\n                ]\n            )\n    # Return the gradient\n    return grad_u3D\n</code></pre>"},{"location":"API/models/#gcrack.models.ElasticModel.sig","title":"<code>sig(u)</code>","text":"<p>Computes the stress tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Function</code> <p>FEM function of the displacement field.</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>ufl.classes.Expr: Stress tensor.</p> Source code in <code>src/gcrack/models.py</code> <pre><code>def sig(self, u: fem.Function) -&gt; ufl.classes.Expr:\n    \"\"\"Computes the stress tensor.\n\n    Args:\n        u (fem.Function): FEM function of the displacement field.\n\n    Returns:\n        ufl.classes.Expr: Stress tensor.\n    \"\"\"\n    # Get elastic parameters\n    mu, la = self.mu, self.la\n    # Compute the stress\n    eps = self.eps(u)\n    return la * ufl.tr(eps) * ufl.Identity(3) + 2 * mu * eps\n</code></pre>"},{"location":"API/models/#gcrack.models.ElasticModel.u_to_3D","title":"<code>u_to_3D(u)</code>","text":"<p>Converts a 2D displacement field to its 3D version.</p> <p>The conversion depends on the 2D assumption (plane stress, plane strain, or anti-plane).</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Function</code> <p>FEM function of the displacement field.</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>ufl.classes.Expr: Displacement in 3D.</p> Source code in <code>src/gcrack/models.py</code> <pre><code>def u_to_3D(self, u: fem.Function) -&gt; ufl.classes.Expr:\n    \"\"\"Converts a 2D displacement field to its 3D version.\n\n    The conversion depends on the 2D assumption (plane stress, plane strain, or anti-plane).\n\n    Args:\n        u (fem.Function): FEM function of the displacement field.\n\n    Returns:\n        ufl.classes.Expr: Displacement in 3D.\n    \"\"\"\n    if self.assumption.startswith(\"plane\"):\n        return ufl.as_vector([u[0], u[1], 0])\n    elif self.assumption == \"anti_plane\":\n        return ufl.as_vector([0.0, 0.0, u[0]])\n    else:\n        raise ValueError(f\"Unknown 2D assumption: {self.assumption}.\")\n</code></pre>"},{"location":"API/optimization_solvers/","title":"Optimization solvers","text":"<p>Module for solving the optimization problem to determine the load factor in crack propagation simulations.</p> <p>This module provides the <code>LoadFactorSolver</code> class, which implements the GMERR (Generalized Maximum Energy Release Rate) criterion for crack propagation. The solver is based on the work of Amestoy and Leblond (1992) and is designed to work with the <code>gcrack.lefm</code> module. It uses gradient descent with line search to find the optimal crack propagation angle and load factor.</p> <p>The module also includes a custom gradient descent optimizer with line search for robust convergence, even in the presence of discontinuities or \"cups\" in critical energy release rate Gc.</p> References <p>Amestoy, M., &amp; Leblond, J. B. (1992). A new numerical method for crack growth prediction. International Journal of Solids and Structures, 29(21), 2619-2638. https://doi.org/10.1016/0020-7683(92)90210-K</p>"},{"location":"API/optimization_solvers/#gcrack.optimization_solvers.LoadFactorSolver","title":"<code>LoadFactorSolver</code>","text":"<p>Solver for load factors and crack propagation angles using the GMERR criterion.</p> <p>This class implements the GMERR (Generalized Maximum Energy Release Rate) criterion for crack propagation. It uses automatic differentiation to compute gradients and Hessians of the objective function, and employs gradient descent with line search to find the optimal crack propagation angle and load factor.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>ElasticModel</code> <p>The elastic model used for the simulation.</p> <code>Gc</code> <code>Callable</code> <p>The critical energy release rate function.</p> <code>grad</code> <code>Callable</code> <p>The gradient of the objective function.</p> <code>hess</code> <code>Callable</code> <p>The Hessian of the objective function.</p> <code>grad_pert</code> <code>Callable</code> <p>The gradient of the perturbed objective function.</p> <code>hess_pert</code> <code>Callable</code> <p>The Hessian of the perturbed objective function.</p> Source code in <code>src/gcrack/optimization_solvers.py</code> <pre><code>class LoadFactorSolver:\n    \"\"\"Solver for load factors and crack propagation angles using the GMERR criterion.\n\n    This class implements the GMERR (Generalized Maximum Energy Release Rate) criterion for crack propagation.\n    It uses automatic differentiation to compute gradients and Hessians of the objective function, and employs gradient descent with line search to find the optimal crack propagation angle and load factor.\n\n    Attributes:\n        model (gcrack.models.ElasticModel): The elastic model used for the simulation.\n        Gc (Callable): The critical energy release rate function.\n        grad (Callable): The gradient of the objective function.\n        hess (Callable): The Hessian of the objective function.\n        grad_pert (Callable): The gradient of the perturbed objective function.\n        hess_pert (Callable): The Hessian of the perturbed objective function.\n    \"\"\"\n\n    def __init__(self, model: ElasticModel, Gc_func: Callable, xc: List):\n        \"\"\"Initializes the LoadFactorSolver.\n\n        Args:\n            model (gcrack.models.ElasticModel): The elastic model used for the simulation.\n            Gc_func (Callable): The critical energy release rate function.\n            xc (List): Position of the crack tip.\n        \"\"\"\n        # Store the model\n        self.model = model\n        # Store the crack tip position\n        self.xc = xc\n        # Set the critical energy release rate function\n        self.Gc = jit(Gc_func)\n        # Automatic differentiation of the objective function\n        self.grad = jit(grad(self.objective))\n        self.hess = jit(hessian(self.objective))\n        # Automatic differentiation of the perturbed objective function\n        self.grad_pert = jit(grad(self.objective_pert))\n        self.hess_pert = jit(hessian(self.objective_pert))\n\n    def objective(\n        self,\n        x: jnp.ndarray,\n        Ep: float,\n        s: float,\n        KIc: float,\n        KIIc: float,\n        Tc: float,\n        KIp: float,\n        KIIp: float,\n        Tp: float,\n        phi0: float,\n    ) -&gt; float:\n        \"\"\"Computes the objective function for the GMERR criterion.\n\n        This function computes the objective function for the GMERR criterion, which is used to find the optimal crack propagation angle and load factor.\n\n        Args:\n            x (jnp.ndarray): The optimization variables (crack propagation angle).\n            Ep (float): Plane strain modulus.\n            s (float): Internal length associated with T-stress.\n            KIc (float): Mode I stress intensity factor for the controlled problem.\n            KIIc (float): Mode II stress intensity factor for the controlled problem.\n            Tc (float): T-stress for the controlled problem.\n            KIp (float): Mode I stress intensity factor for the prescribed problem.\n            KIIp (float): Mode II stress intensity factor for the prescribed problem.\n            Tp (float): T-stress for the prescribed problem.\n            phi0 (float): Initial crack angle.\n\n        Returns:\n            float: The value of the objective function.\n        \"\"\"\n        # NOTE: The KIc (etc.) means controlled (not critical!)\n        phi = x[0]\n        # Compute the G star\n        Gs_cc = G_star(phi, phi0, KIc, KIIc, Tc, Ep, s)\n        Gs_cp = G_star_coupled(phi, phi0, KIc, KIIc, Tc, KIp, KIIp, Tp, Ep, s)\n        Gs_pp = G_star(phi, phi0, KIp, KIIp, Tp, Ep, s)\n        # Compute the Gc from phi\n        gc = self.Gc(phi)\n        # Compute and return the load factor\n        delta = Gs_cp**2 - 4 * Gs_cc * (Gs_pp - gc)\n        return (-Gs_cp + jnp.sqrt(delta)) / (2 * Gs_cc)\n\n    def objective_pert(\n        self,\n        x: jnp.ndarray,\n        Ep: float,\n        s: float,\n        KIc: float,\n        KIIc: float,\n        Tc: float,\n        KIp: float,\n        KIIp: float,\n        Tp: float,\n        phi0: float,\n    ) -&gt; float:\n        \"\"\"Computes the perturbed objective function for the GMERR criterion.\n\n        This function adds a small perturbation to the objective function to avoid\n        convergence to a maximum instead of a minimum.\n\n        Args:\n            x (jnp.ndarray): The optimization variables (crack propagation angle).\n            Ep (float): Plane strain modulus.\n            s (float): Internal length associated with T-stress.\n            KIc (float): Mode I stress intensity factor for the controlled problem.\n            KIIc (float): Mode II stress intensity factor for the controlled problem.\n            Tc (float): T-stress for the controlled problem.\n            KIp (float): Mode I stress intensity factor for the prescribed problem.\n            KIIp (float): Mode II stress intensity factor for the prescribed problem.\n            Tp (float): T-stress for the prescribed problem.\n            phi0 (float): Initial crack angle.\n\n        Returns:\n            float: The value of the perturbed objective function.\n        \"\"\"\n        return (\n            self.objective(x, Ep, s, KIc, KIIc, Tc, KIp, KIIp, Tp, phi0) + 1e-5 * x[0]\n        )\n\n    def solve(\n        self, phi0: float, SIFs_controlled: dict, SIFs_prescribed: dict, s: float\n    ):\n        \"\"\"Solves for the optimal crack propagation angle and load factor.\n\n        This function uses gradient descent with line search to find the optimal\n        crack propagation angle and load factor.\n\n        Args:\n            phi0 (float): Initial crack angle.\n            SIFs_controlled (dict): Stress intensity factors for the controlled problem.\n            SIFs_prescribed (dict): Stress intensity factors for the prescribed problem.\n            s (float): Internal length associated with T-stress.\n\n        Returns:\n            Tuple[float, float]: The optimal crack propagation angle and load factor.\n        \"\"\"\n        KIc, KIIc, Tc = (\n            SIFs_controlled[\"KI\"],\n            SIFs_controlled[\"KII\"],\n            SIFs_controlled[\"T\"],\n        )\n        KIp, KIIp, Tp = (\n            SIFs_prescribed[\"KI\"],\n            SIFs_prescribed[\"KII\"],\n            SIFs_prescribed[\"T\"],\n        )\n\n        # Perform the minimization\n        kwargs = {\n            \"Ep\": self.model.Ep_func(self.xc),\n            \"s\": s,\n            \"KIc\": KIc,\n            \"KIIc\": KIIc,\n            \"Tc\": Tc,\n            \"KIp\": KIp,\n            \"KIIp\": KIIp,\n            \"Tp\": Tp,\n            \"phi0\": phi0,\n        }\n\n        phi = gradient_descent_with_line_search(phi0, self.grad, kwargs=kwargs)\n\n        # Check the stability of the solution (i.e., check if solution is a max)\n        hess = self.hess([phi], **kwargs)[0][0]\n        solution_is_max = hess &lt; 0\n        if solution_is_max:\n            print(\"Found a maximum instead of minimum -&gt; perturbating the objective\")\n            print(\"Note: this test might also be triggered by cups!\")\n            # Perform another gradient descent on the perturbed objective\n            phi = gradient_descent_with_line_search(phi0, self.grad_pert, kwargs=kwargs)\n\n        # Compute the load factor\n        load_factor = self.objective([phi], **kwargs)\n\n        return float(phi), float(load_factor)\n\n    def export_minimization_plots(\n        self,\n        phi: float,\n        load_factor: float,\n        phi0: float,\n        SIFs_controlled: dict,\n        SIFs_prescribed: dict,\n        s: float,\n        t: int,\n        dir_name: Path,\n    ):\n        \"\"\"Exports plots of the objective function and its gradient during minimization.\n\n        This function generates and saves plots of the objective function, its perturbed\n        version, and the gradient of the objective function during the minimization process.\n        This function is mainly use to illustrate the minimization.\n\n        Args:\n            phi (float): Optimal crack propagation angle.\n            load_factor (float): Optimal load factor.\n            phi0 (float): Initial crack angle.\n            SIFs_controlled (dict): Stress intensity factors for the controlled problem.\n            SIFs_prescribed (dict): Stress intensity factors for the prescribed problem.\n            s (float): Internal length associated with T-stress.\n            t (int): Current time step.\n            dir_name (Path): Directory to save the plots.\n        \"\"\"\n        # Extract the SIFs\n        KIc, KIIc, Tc = (\n            SIFs_controlled[\"KI\"],\n            SIFs_controlled[\"KII\"],\n            SIFs_controlled[\"T\"],\n        )\n        KIp, KIIp, Tp = (\n            SIFs_prescribed[\"KI\"],\n            SIFs_prescribed[\"KII\"],\n            SIFs_prescribed[\"T\"],\n        )\n        # Construct the kwargs\n        kwargs = {\n            \"Ep\": self.model.Ep_func(self.xc),\n            \"s\": s,\n            \"KIc\": KIc,\n            \"KIIc\": KIIc,\n            \"Tc\": Tc,\n            \"KIp\": KIp,\n            \"KIIp\": KIIp,\n            \"Tp\": Tp,\n            \"phi0\": phi0,\n        }\n\n        # Display the objective function (and its minimum)\n        plt.figure()\n        plt.xlabel(r\"Bifurcation angle $\\varphi$ (rad)\")\n        plt.ylabel(r\"Load factor $\\sqrt{\\frac{G_c(\\varphi)}{G^*(\\varphi)}}$\")\n        phis = jnp.linspace(phi0 - pi / 2, phi0 + pi / 2, num=180).__array__()\n        objs = [self.objective([phi], **kwargs) for phi in phis]\n        objs_pert = [self.objective_pert([phi], **kwargs) for phi in phis]\n        plt.plot(phis, objs, label=\"Objective\")\n        plt.plot(phis, objs_pert, label=\"Perturbated objective\")\n        plt.scatter([phi], [self.objective([phi], **kwargs)], c=\"r\")\n        plt.grid()\n        plt.legend()\n        plt.tight_layout()\n        plt.savefig(dir_name / f\"objective_function_{t:08d}.svg\")\n\n        plt.figure()\n        plt.xlabel(r\"Bifurcation angle $\\varphi$ (rad)\")\n        plt.ylabel(r\"Derivative of the load factor\")\n        grads = [self.grad([phi_], **kwargs)[0] for phi_ in phis]\n        plt.scatter([phi], [self.grad([phi], **kwargs)[0]], c=\"r\")\n        plt.plot(phis, grads)\n        plt.grid()\n        plt.tight_layout()\n        plt.savefig(dir_name / f\"residual_function_{t:08d}.svg\")\n\n        plt.close(\"all\")\n</code></pre>"},{"location":"API/optimization_solvers/#gcrack.optimization_solvers.LoadFactorSolver.__init__","title":"<code>__init__(model, Gc_func, xc)</code>","text":"<p>Initializes the LoadFactorSolver.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ElasticModel</code> <p>The elastic model used for the simulation.</p> required <code>Gc_func</code> <code>Callable</code> <p>The critical energy release rate function.</p> required <code>xc</code> <code>List</code> <p>Position of the crack tip.</p> required Source code in <code>src/gcrack/optimization_solvers.py</code> <pre><code>def __init__(self, model: ElasticModel, Gc_func: Callable, xc: List):\n    \"\"\"Initializes the LoadFactorSolver.\n\n    Args:\n        model (gcrack.models.ElasticModel): The elastic model used for the simulation.\n        Gc_func (Callable): The critical energy release rate function.\n        xc (List): Position of the crack tip.\n    \"\"\"\n    # Store the model\n    self.model = model\n    # Store the crack tip position\n    self.xc = xc\n    # Set the critical energy release rate function\n    self.Gc = jit(Gc_func)\n    # Automatic differentiation of the objective function\n    self.grad = jit(grad(self.objective))\n    self.hess = jit(hessian(self.objective))\n    # Automatic differentiation of the perturbed objective function\n    self.grad_pert = jit(grad(self.objective_pert))\n    self.hess_pert = jit(hessian(self.objective_pert))\n</code></pre>"},{"location":"API/optimization_solvers/#gcrack.optimization_solvers.LoadFactorSolver.export_minimization_plots","title":"<code>export_minimization_plots(phi, load_factor, phi0, SIFs_controlled, SIFs_prescribed, s, t, dir_name)</code>","text":"<p>Exports plots of the objective function and its gradient during minimization.</p> <p>This function generates and saves plots of the objective function, its perturbed version, and the gradient of the objective function during the minimization process. This function is mainly use to illustrate the minimization.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>Optimal crack propagation angle.</p> required <code>load_factor</code> <code>float</code> <p>Optimal load factor.</p> required <code>phi0</code> <code>float</code> <p>Initial crack angle.</p> required <code>SIFs_controlled</code> <code>dict</code> <p>Stress intensity factors for the controlled problem.</p> required <code>SIFs_prescribed</code> <code>dict</code> <p>Stress intensity factors for the prescribed problem.</p> required <code>s</code> <code>float</code> <p>Internal length associated with T-stress.</p> required <code>t</code> <code>int</code> <p>Current time step.</p> required <code>dir_name</code> <code>Path</code> <p>Directory to save the plots.</p> required Source code in <code>src/gcrack/optimization_solvers.py</code> <pre><code>def export_minimization_plots(\n    self,\n    phi: float,\n    load_factor: float,\n    phi0: float,\n    SIFs_controlled: dict,\n    SIFs_prescribed: dict,\n    s: float,\n    t: int,\n    dir_name: Path,\n):\n    \"\"\"Exports plots of the objective function and its gradient during minimization.\n\n    This function generates and saves plots of the objective function, its perturbed\n    version, and the gradient of the objective function during the minimization process.\n    This function is mainly use to illustrate the minimization.\n\n    Args:\n        phi (float): Optimal crack propagation angle.\n        load_factor (float): Optimal load factor.\n        phi0 (float): Initial crack angle.\n        SIFs_controlled (dict): Stress intensity factors for the controlled problem.\n        SIFs_prescribed (dict): Stress intensity factors for the prescribed problem.\n        s (float): Internal length associated with T-stress.\n        t (int): Current time step.\n        dir_name (Path): Directory to save the plots.\n    \"\"\"\n    # Extract the SIFs\n    KIc, KIIc, Tc = (\n        SIFs_controlled[\"KI\"],\n        SIFs_controlled[\"KII\"],\n        SIFs_controlled[\"T\"],\n    )\n    KIp, KIIp, Tp = (\n        SIFs_prescribed[\"KI\"],\n        SIFs_prescribed[\"KII\"],\n        SIFs_prescribed[\"T\"],\n    )\n    # Construct the kwargs\n    kwargs = {\n        \"Ep\": self.model.Ep_func(self.xc),\n        \"s\": s,\n        \"KIc\": KIc,\n        \"KIIc\": KIIc,\n        \"Tc\": Tc,\n        \"KIp\": KIp,\n        \"KIIp\": KIIp,\n        \"Tp\": Tp,\n        \"phi0\": phi0,\n    }\n\n    # Display the objective function (and its minimum)\n    plt.figure()\n    plt.xlabel(r\"Bifurcation angle $\\varphi$ (rad)\")\n    plt.ylabel(r\"Load factor $\\sqrt{\\frac{G_c(\\varphi)}{G^*(\\varphi)}}$\")\n    phis = jnp.linspace(phi0 - pi / 2, phi0 + pi / 2, num=180).__array__()\n    objs = [self.objective([phi], **kwargs) for phi in phis]\n    objs_pert = [self.objective_pert([phi], **kwargs) for phi in phis]\n    plt.plot(phis, objs, label=\"Objective\")\n    plt.plot(phis, objs_pert, label=\"Perturbated objective\")\n    plt.scatter([phi], [self.objective([phi], **kwargs)], c=\"r\")\n    plt.grid()\n    plt.legend()\n    plt.tight_layout()\n    plt.savefig(dir_name / f\"objective_function_{t:08d}.svg\")\n\n    plt.figure()\n    plt.xlabel(r\"Bifurcation angle $\\varphi$ (rad)\")\n    plt.ylabel(r\"Derivative of the load factor\")\n    grads = [self.grad([phi_], **kwargs)[0] for phi_ in phis]\n    plt.scatter([phi], [self.grad([phi], **kwargs)[0]], c=\"r\")\n    plt.plot(phis, grads)\n    plt.grid()\n    plt.tight_layout()\n    plt.savefig(dir_name / f\"residual_function_{t:08d}.svg\")\n\n    plt.close(\"all\")\n</code></pre>"},{"location":"API/optimization_solvers/#gcrack.optimization_solvers.LoadFactorSolver.objective","title":"<code>objective(x, Ep, s, KIc, KIIc, Tc, KIp, KIIp, Tp, phi0)</code>","text":"<p>Computes the objective function for the GMERR criterion.</p> <p>This function computes the objective function for the GMERR criterion, which is used to find the optimal crack propagation angle and load factor.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The optimization variables (crack propagation angle).</p> required <code>Ep</code> <code>float</code> <p>Plane strain modulus.</p> required <code>s</code> <code>float</code> <p>Internal length associated with T-stress.</p> required <code>KIc</code> <code>float</code> <p>Mode I stress intensity factor for the controlled problem.</p> required <code>KIIc</code> <code>float</code> <p>Mode II stress intensity factor for the controlled problem.</p> required <code>Tc</code> <code>float</code> <p>T-stress for the controlled problem.</p> required <code>KIp</code> <code>float</code> <p>Mode I stress intensity factor for the prescribed problem.</p> required <code>KIIp</code> <code>float</code> <p>Mode II stress intensity factor for the prescribed problem.</p> required <code>Tp</code> <code>float</code> <p>T-stress for the prescribed problem.</p> required <code>phi0</code> <code>float</code> <p>Initial crack angle.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the objective function.</p> Source code in <code>src/gcrack/optimization_solvers.py</code> <pre><code>def objective(\n    self,\n    x: jnp.ndarray,\n    Ep: float,\n    s: float,\n    KIc: float,\n    KIIc: float,\n    Tc: float,\n    KIp: float,\n    KIIp: float,\n    Tp: float,\n    phi0: float,\n) -&gt; float:\n    \"\"\"Computes the objective function for the GMERR criterion.\n\n    This function computes the objective function for the GMERR criterion, which is used to find the optimal crack propagation angle and load factor.\n\n    Args:\n        x (jnp.ndarray): The optimization variables (crack propagation angle).\n        Ep (float): Plane strain modulus.\n        s (float): Internal length associated with T-stress.\n        KIc (float): Mode I stress intensity factor for the controlled problem.\n        KIIc (float): Mode II stress intensity factor for the controlled problem.\n        Tc (float): T-stress for the controlled problem.\n        KIp (float): Mode I stress intensity factor for the prescribed problem.\n        KIIp (float): Mode II stress intensity factor for the prescribed problem.\n        Tp (float): T-stress for the prescribed problem.\n        phi0 (float): Initial crack angle.\n\n    Returns:\n        float: The value of the objective function.\n    \"\"\"\n    # NOTE: The KIc (etc.) means controlled (not critical!)\n    phi = x[0]\n    # Compute the G star\n    Gs_cc = G_star(phi, phi0, KIc, KIIc, Tc, Ep, s)\n    Gs_cp = G_star_coupled(phi, phi0, KIc, KIIc, Tc, KIp, KIIp, Tp, Ep, s)\n    Gs_pp = G_star(phi, phi0, KIp, KIIp, Tp, Ep, s)\n    # Compute the Gc from phi\n    gc = self.Gc(phi)\n    # Compute and return the load factor\n    delta = Gs_cp**2 - 4 * Gs_cc * (Gs_pp - gc)\n    return (-Gs_cp + jnp.sqrt(delta)) / (2 * Gs_cc)\n</code></pre>"},{"location":"API/optimization_solvers/#gcrack.optimization_solvers.LoadFactorSolver.objective_pert","title":"<code>objective_pert(x, Ep, s, KIc, KIIc, Tc, KIp, KIIp, Tp, phi0)</code>","text":"<p>Computes the perturbed objective function for the GMERR criterion.</p> <p>This function adds a small perturbation to the objective function to avoid convergence to a maximum instead of a minimum.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The optimization variables (crack propagation angle).</p> required <code>Ep</code> <code>float</code> <p>Plane strain modulus.</p> required <code>s</code> <code>float</code> <p>Internal length associated with T-stress.</p> required <code>KIc</code> <code>float</code> <p>Mode I stress intensity factor for the controlled problem.</p> required <code>KIIc</code> <code>float</code> <p>Mode II stress intensity factor for the controlled problem.</p> required <code>Tc</code> <code>float</code> <p>T-stress for the controlled problem.</p> required <code>KIp</code> <code>float</code> <p>Mode I stress intensity factor for the prescribed problem.</p> required <code>KIIp</code> <code>float</code> <p>Mode II stress intensity factor for the prescribed problem.</p> required <code>Tp</code> <code>float</code> <p>T-stress for the prescribed problem.</p> required <code>phi0</code> <code>float</code> <p>Initial crack angle.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The value of the perturbed objective function.</p> Source code in <code>src/gcrack/optimization_solvers.py</code> <pre><code>def objective_pert(\n    self,\n    x: jnp.ndarray,\n    Ep: float,\n    s: float,\n    KIc: float,\n    KIIc: float,\n    Tc: float,\n    KIp: float,\n    KIIp: float,\n    Tp: float,\n    phi0: float,\n) -&gt; float:\n    \"\"\"Computes the perturbed objective function for the GMERR criterion.\n\n    This function adds a small perturbation to the objective function to avoid\n    convergence to a maximum instead of a minimum.\n\n    Args:\n        x (jnp.ndarray): The optimization variables (crack propagation angle).\n        Ep (float): Plane strain modulus.\n        s (float): Internal length associated with T-stress.\n        KIc (float): Mode I stress intensity factor for the controlled problem.\n        KIIc (float): Mode II stress intensity factor for the controlled problem.\n        Tc (float): T-stress for the controlled problem.\n        KIp (float): Mode I stress intensity factor for the prescribed problem.\n        KIIp (float): Mode II stress intensity factor for the prescribed problem.\n        Tp (float): T-stress for the prescribed problem.\n        phi0 (float): Initial crack angle.\n\n    Returns:\n        float: The value of the perturbed objective function.\n    \"\"\"\n    return (\n        self.objective(x, Ep, s, KIc, KIIc, Tc, KIp, KIIp, Tp, phi0) + 1e-5 * x[0]\n    )\n</code></pre>"},{"location":"API/optimization_solvers/#gcrack.optimization_solvers.LoadFactorSolver.solve","title":"<code>solve(phi0, SIFs_controlled, SIFs_prescribed, s)</code>","text":"<p>Solves for the optimal crack propagation angle and load factor.</p> <p>This function uses gradient descent with line search to find the optimal crack propagation angle and load factor.</p> <p>Parameters:</p> Name Type Description Default <code>phi0</code> <code>float</code> <p>Initial crack angle.</p> required <code>SIFs_controlled</code> <code>dict</code> <p>Stress intensity factors for the controlled problem.</p> required <code>SIFs_prescribed</code> <code>dict</code> <p>Stress intensity factors for the prescribed problem.</p> required <code>s</code> <code>float</code> <p>Internal length associated with T-stress.</p> required <p>Returns:</p> Type Description <p>Tuple[float, float]: The optimal crack propagation angle and load factor.</p> Source code in <code>src/gcrack/optimization_solvers.py</code> <pre><code>def solve(\n    self, phi0: float, SIFs_controlled: dict, SIFs_prescribed: dict, s: float\n):\n    \"\"\"Solves for the optimal crack propagation angle and load factor.\n\n    This function uses gradient descent with line search to find the optimal\n    crack propagation angle and load factor.\n\n    Args:\n        phi0 (float): Initial crack angle.\n        SIFs_controlled (dict): Stress intensity factors for the controlled problem.\n        SIFs_prescribed (dict): Stress intensity factors for the prescribed problem.\n        s (float): Internal length associated with T-stress.\n\n    Returns:\n        Tuple[float, float]: The optimal crack propagation angle and load factor.\n    \"\"\"\n    KIc, KIIc, Tc = (\n        SIFs_controlled[\"KI\"],\n        SIFs_controlled[\"KII\"],\n        SIFs_controlled[\"T\"],\n    )\n    KIp, KIIp, Tp = (\n        SIFs_prescribed[\"KI\"],\n        SIFs_prescribed[\"KII\"],\n        SIFs_prescribed[\"T\"],\n    )\n\n    # Perform the minimization\n    kwargs = {\n        \"Ep\": self.model.Ep_func(self.xc),\n        \"s\": s,\n        \"KIc\": KIc,\n        \"KIIc\": KIIc,\n        \"Tc\": Tc,\n        \"KIp\": KIp,\n        \"KIIp\": KIIp,\n        \"Tp\": Tp,\n        \"phi0\": phi0,\n    }\n\n    phi = gradient_descent_with_line_search(phi0, self.grad, kwargs=kwargs)\n\n    # Check the stability of the solution (i.e., check if solution is a max)\n    hess = self.hess([phi], **kwargs)[0][0]\n    solution_is_max = hess &lt; 0\n    if solution_is_max:\n        print(\"Found a maximum instead of minimum -&gt; perturbating the objective\")\n        print(\"Note: this test might also be triggered by cups!\")\n        # Perform another gradient descent on the perturbed objective\n        phi = gradient_descent_with_line_search(phi0, self.grad_pert, kwargs=kwargs)\n\n    # Compute the load factor\n    load_factor = self.objective([phi], **kwargs)\n\n    return float(phi), float(load_factor)\n</code></pre>"},{"location":"API/optimization_solvers/#gcrack.optimization_solvers.gradient_descent_with_line_search","title":"<code>gradient_descent_with_line_search(phi0, gra, tol=1e-06, max_iter=10000, kwargs={})</code>","text":"<p>Performs gradient descent with line search to minimize an objective function.</p> <p>This function implements gradient descent with a custom line search to find the minimum of an objective function. It is designed to handle discontinuities and \"cups\" in the objective function.</p> <p>Parameters:</p> Name Type Description Default <code>phi0</code> <code>float</code> <p>Initial guess for the crack propagation angle.</p> required <code>gra</code> <code>Callable</code> <p>The gradient of the objective function.</p> required <code>tol</code> <code>float</code> <p>Tolerance for convergence.</p> <code>1e-06</code> <code>max_iter</code> <code>int</code> <p>Maximum number of iterations.</p> <code>10000</code> <code>kwargs</code> <code>dict</code> <p>Additional arguments to pass to the gradient function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The optimal crack propagation angle.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the gradient descent fails to converge.</p> Source code in <code>src/gcrack/optimization_solvers.py</code> <pre><code>def gradient_descent_with_line_search(\n    phi0: float,\n    gra: Callable,\n    tol: float = 1e-6,\n    max_iter: int = 10_000,\n    kwargs: dict = {},\n) -&gt; float:\n    \"\"\"Performs gradient descent with line search to minimize an objective function.\n\n    This function implements gradient descent with a custom line search to find the minimum\n    of an objective function. It is designed to handle discontinuities and \"cups\" in the\n    objective function.\n\n    Args:\n        phi0 (float): Initial guess for the crack propagation angle.\n        gra (Callable): The gradient of the objective function.\n        tol (float): Tolerance for convergence.\n        max_iter (int): Maximum number of iterations.\n        kwargs (dict): Additional arguments to pass to the gradient function.\n\n    Returns:\n        float: The optimal crack propagation angle.\n\n    Raises:\n        RuntimeError: If the gradient descent fails to converge.\n    \"\"\"\n    print(\"\u2502  \u2502  Running the gradient descent with custom line search\")\n    # Initialization\n    phi = float(phi0)\n    converged = False\n    for i in range(max_iter):\n        # Determine the direction\n        direction = -gra([phi], **kwargs)[0]\n        # Check if the direction is close to 0\n        if jnp.isclose(direction, 0):\n            # Set a null increment\n            dphi = 0\n            # Set a null idx\n            idx = 0\n        else:\n            # Apply line-search\n            cs = [0.0] + [(jnp.pi / 2) ** k for k in range(-29, 2)]\n            phis_test = jnp.array([phi + c * jnp.sign(direction) for c in cs])\n            # Get the index associated with the first increase of the objective\n            diff = jnp.array([gra([phi_test], **kwargs)[0] for phi_test in phis_test])\n            # Create an array with the slope \"in the direction of minimization\"\n            slope = jnp.sign(direction) * diff\n            if jnp.all(slope &lt; 0):\n                # If the slope is always negative, take the largest step\n                idx = -1\n            elif jnp.all(slope &gt; 0):\n                # If the slope is always positive, take no step\n                idx = 0\n            else:\n                # If the slope increases after a decrease, then local minimum\n                idx = jnp.where(slope &gt; 0)[0][0] - 1\n                # If the first grad is positive, we are at the solution\n                # This case only occurs when the grad is discontinuous (cups)\n                if idx == -1:\n                    idx = 0\n            # Calculate the increment\n            dphi = phis_test[idx] - phi\n        # Update the solution\n        phi += dphi\n        # Generate an info message\n        msg = \"\u2502  \u2502  \u2502  \"\n        msg += f\"Step: {i + 1:06d} | \"\n        msg += f\"phi: {jnp.rad2deg(phi):+7.2f}\u00b0 | \"\n        msg += f\"dphi: {abs(dphi):8.3g}\"\n        print(msg)\n        # Check the convergence\n        converged = idx == 0 or abs(dphi) &lt;= tol\n        if converged:\n            print(\"\u2502  \u2502  \u2502  Converged\")\n            break\n        else:\n            # Clip the angle phi\n            phi = min(max(phi0 - 2 * jnp.pi / 3, phi), phi0 + 2 * jnp.pi / 3)\n\n    # Check the convergence\n    if not converged:\n        raise RuntimeError(\" \u2514\u2500 Gradient descent failed to converge!\")\n    return phi\n</code></pre>"},{"location":"API/postprocess/","title":"Postprocess","text":"<p>Module for computing post-processing quantities in finite element simulations of elastic problems.</p> <p>This module provides functions to compute various post-processing quantities in finite element simulations, including reaction forces, displacements at specific points, elastic energy, and external work.</p> <p>Functions:</p> Name Description <code>compute_measured_forces</code> <p>Computes the reaction forces on a specified boundary.</p> <code>compute_measured_displacement</code> <p>Computes the displacement at a specified point.</p> <code>compute_elastic_energy</code> <p>Computes the elastic energy in the domain.</p> <code>compute_external_work</code> <p>Computes the external work done on the domain.</p>"},{"location":"API/postprocess/#gcrack.postprocess.compute_elastic_energy","title":"<code>compute_elastic_energy(domain, model, uh)</code>","text":"<p>Compute the elastic energy in the domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain of the problem.</p> required <code>model</code> <code>ElasticModel</code> <p>The elastic model being used.</p> required <code>uh</code> <code>Function</code> <p>The displacement solution of the elastic problem.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Elastic energy.</p> Source code in <code>src/gcrack/postprocess.py</code> <pre><code>def compute_elastic_energy(\n    domain: Domain, model: ElasticModel, uh: fem.Function\n) -&gt; float:\n    \"\"\"Compute the elastic energy in the domain.\n\n    Args:\n        domain (Domain): The domain of the problem.\n        model (ElasticModel): The elastic model being used.\n        uh (Function): The displacement solution of the elastic problem.\n\n    Returns:\n        float: Elastic energy.\n    \"\"\"\n    # Compute the elastic energy\n    return fem.assemble_scalar(fem.form(model.elastic_energy(uh, domain)))\n</code></pre>"},{"location":"API/postprocess/#gcrack.postprocess.compute_external_work","title":"<code>compute_external_work(domain, model, uh)</code>","text":"<p>Compute the external work.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain of the problem.</p> required <code>model</code> <code>ElasticModel</code> <p>The elastic model being used.</p> required <code>uh</code> <code>Function</code> <p>The displacement solution of the elastic problem.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>External work.</p> Source code in <code>src/gcrack/postprocess.py</code> <pre><code>def compute_external_work(\n    domain: Domain, model: ElasticModel, uh: fem.Function\n) -&gt; float:\n    \"\"\"Compute the external work.\n\n    Args:\n        domain (Domain): The domain of the problem.\n        model (ElasticModel): The elastic model being used.\n        uh (Function): The displacement solution of the elastic problem.\n\n    Returns:\n        float: External work.\n    \"\"\"\n    # Get surface measure\n    ds = ufl.Measure(\"ds\", domain=domain.mesh)\n    # Get the normal\n    facet_normal: ufl.FacetNormal = ufl.FacetNormal(domain.mesh)\n    n = ufl.as_vector([facet_normal[0], facet_normal[1], 0])\n    # Convert displacement to 3D\n    uh3D = model.u_to_3D(uh)\n    # Define the ufl expression of the external work\n    ew_ufl = ufl.dot(ufl.dot(model.sig(uh), n), uh3D) * ds\n    # Compute the elastic energy\n    return fem.assemble_scalar(fem.form(ew_ufl))\n</code></pre>"},{"location":"API/postprocess/#gcrack.postprocess.compute_measured_displacement","title":"<code>compute_measured_displacement(domain, uh, gcrack_data)</code>","text":"<p>Compute the displacement at the specified point.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain of the problem.</p> required <code>uh</code> <code>Function</code> <p>The displacement solution of the elastic problem.</p> required <p>Returns:</p> Type Description <code>array</code> <p>np.array: The computed displacement as a numpy array.</p> Source code in <code>src/gcrack/postprocess.py</code> <pre><code>def compute_measured_displacement(\n    domain: Domain, uh: fem.Function, gcrack_data\n) -&gt; np.array:\n    \"\"\"Compute the displacement at the specified point.\n\n    Args:\n        domain (Domain): The domain of the problem.\n        uh (Function): The displacement solution of the elastic problem.\n\n    Returns:\n        np.array: The computed displacement as a numpy array.\n    \"\"\"\n    # Get the mesh\n    mesh = domain.mesh\n    # Get the position of the measurement\n    x = gcrack_data.locate_measured_displacement()\n    if len(x) == 2:\n        x.append(0)\n    # Store x in an array\n    xs = np.array([x])\n    # Generate the bounding box tree\n    tree = geometry.bb_tree(mesh, mesh.topology.dim)\n    # Find cells whose bounding-box collide with the points\n    cell_candidates = geometry.compute_collisions_points(tree, xs)\n    # For each points, choose one of the cells that contains the point\n    colliding_cells = geometry.compute_colliding_cells(mesh, cell_candidates, xs)\n    cell = colliding_cells.array[0]\n    # Compute the measured displacement\n    u_meas = uh.eval(xs, cell)\n    # Initialize the probes values\n    return u_meas\n</code></pre>"},{"location":"API/postprocess/#gcrack.postprocess.compute_measured_forces","title":"<code>compute_measured_forces(domain, model, uh, gcrack_data)</code>","text":"<p>Compute the measured forces.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain of the problem.</p> required <code>model</code> <code>ElasticModel</code> <p>The elastic model being used.</p> required <code>uh</code> <code>Function</code> <p>The displacement solution of the elastic problem.</p> required <p>Returns:</p> Type Description <code>array</code> <p>np.array: The computed reaction forces as a numpy array.</p> Source code in <code>src/gcrack/postprocess.py</code> <pre><code>def compute_measured_forces(\n    domain: Domain, model: ElasticModel, uh: fem.Function, gcrack_data\n) -&gt; np.array:\n    \"\"\"Compute the measured forces.\n\n    Args:\n        domain (Domain): The domain of the problem.\n        model (ElasticModel): The elastic model being used.\n        uh (Function): The displacement solution of the elastic problem.\n\n    Returns:\n        np.array: The computed reaction forces as a numpy array.\n    \"\"\"\n    # Get the number of components\n    N_comp = uh.function_space.value_shape[0]\n    # Get the normal to the boundary\n    facet_normal: ufl.FacetNormal = ufl.FacetNormal(domain.mesh)\n    n = ufl.as_vector([facet_normal[0], facet_normal[1], 0])\n    # Get the boundary id\n    boundary_id = gcrack_data.locate_measured_forces()\n    # Get the integrand over the boundary\n    ds = ufl.Measure(\n        \"ds\",\n        domain=domain.mesh,\n        subdomain_data=domain.facet_markers,\n        subdomain_id=boundary_id,\n    )\n    # Compute the stress\n    sig = model.sig(uh)\n    # Compute the traction vector\n    T = ufl.dot(sig, n)\n    # Initialize the force array\n    f = np.empty((3,))\n    for comp in range(N_comp):\n        # Elementary vector for the current component\n        elem_vec_np = np.zeros((3,))\n        elem_vec_np[comp] = 1\n        elem_vec = fem.Constant(domain.mesh, elem_vec_np)\n        # Expression for the reaction force for the current component\n        expr = ufl.dot(T, elem_vec) * ds\n        # Form for the reaction force expression\n        form = fem.form(expr)\n        # Assemble the form to get the reaction force component\n        f[comp] = fem.assemble_scalar(form)\n    return f\n</code></pre>"},{"location":"API/solvers/","title":"Solvers","text":"<p>Module with solution method for the elastic problem.</p> <p>This module provides functions for solving elastic problems using the finite element method.</p> <p>Functions:</p> Name Description <code>solve_elastic_problem</code> <p>Solves an elastic problem using the finite element method.</p> <code>compute_external_work</code> <p>Computes the external work due to imposed forces and body forces.</p>"},{"location":"API/solvers/#gcrack.solvers.compute_external_work","title":"<code>compute_external_work(domain, v, bcs)</code>","text":"<p>Computes the external work due to imposed forces and body forces.</p> <p>This function calculates the external work on a boundary of the given mesh by integrating the dot product of imposed traction forces and a test function over the relevant boundary entities. It also accounts for body forces applied within the domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The finite element mesh representing the domain.</p> required <code>v</code> <code>Function</code> <p>The test function representing the virtual displacement or velocity.</p> required <code>bcs</code> <code>BoundaryConditions</code> <p>Object containing the boundary conditions, including body forces and force boundary conditions.</p> required <p>Returns:</p> Type Description <code>Form</code> <p>ufl.classes.Form: A UFL form representing the external work, which can be integrated over the domain or used in variational formulations.</p> Source code in <code>src/gcrack/solvers.py</code> <pre><code>def compute_external_work(\n    domain: Domain, v: dolfinx.fem.Function, bcs: BoundaryConditions\n) -&gt; ufl.classes.Form:\n    \"\"\"Computes the external work due to imposed forces and body forces.\n\n    This function calculates the external work on a boundary of the given mesh by integrating the dot product of imposed traction forces and a test function over the relevant boundary entities.\n    It also accounts for body forces applied within the domain.\n\n    Args:\n        domain (Domain):\n            The finite element mesh representing the domain.\n        v (dolfinx.fem.Function):\n            The test function representing the virtual displacement or velocity.\n        bcs (BoundaryConditions):\n            Object containing the boundary conditions, including body forces and force boundary conditions.\n\n    Returns:\n        ufl.classes.Form:\n            A UFL form representing the external work, which can be integrated over the domain or used in variational formulations.\n    \"\"\"\n\n    \"\"\"\n    Compute the external work on the boundary of the domain due to imposed forces.\n\n    This function calculates the external work on a boundary of the given mesh by\n    integrating the dot product of imposed traction forces and a test function\n    over the relevant boundary entities.\n\n    Args:\n        domain (gcrack.Domain): The finite element mesh representing the domain.\n        v (dolfinx.fem.Function): The test function representing the virtual displacement or velocity.\n        bcs: Object containing the boundary conditions.\n\n    Returns:\n        external_work(ufl.classes.Form):\n            An UFL form representing the external work, which can be integrated over the domain or used in variational formulations.\n\n    \"\"\"\n    # Get the number of components in u\n    N_comp = v.function_space.value_shape[0]\n    # Initialize the external work\n    f = fem.Constant(domain.mesh, [0.0] * N_comp)\n    external_work = ufl.dot(f, v) * ufl.dx\n    # Create a function space for body forces\n    bf_space = fem.functionspace(domain.mesh, (\"Lagrange\", 1))\n    # Iterate through the body forces\n    for bf in bcs.body_forces:\n        # Define the integrand\n        dx = ufl.Measure(\"dx\", domain=domain.mesh)\n        # Convert to ufl vector\n        f_list = []\n        for i, f_comp in enumerate(bf.f_imp):\n            f_comp_parsed = parse_expression(f_comp, bf_space)\n            f_list.append(f_comp_parsed)\n        f = ufl.as_vector(f_list)\n        # Add constant body force to the external work\n        external_work += ufl.dot(f, v) * dx\n\n    # Iterate through the force boundary conditions\n    for f_bc in bcs.force_bcs:\n        # Define the integrand\n        ds = ufl.Measure(\n            \"ds\",\n            domain=domain.mesh,\n            subdomain_data=domain.facet_markers,\n            subdomain_id=f_bc.boundary_id,\n        )\n        T = ufl.as_vector(f_bc.f_imp)\n        # Add the contribution to the external work\n        external_work += ufl.dot(T, v) * ds\n    return external_work\n</code></pre>"},{"location":"API/solvers/#gcrack.solvers.solve_elastic_problem","title":"<code>solve_elastic_problem(domain, model, bcs)</code>","text":"<p>Solves an elastic problem using the finite element method.</p> <p>This function sets up and solves a linear elastic problem using the finite element method. It defines the function space, boundary conditions, and variational formulation based on the elastic energy and external work. The problem is solved using PETSc's LinearProblem.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain object representing the physical space.</p> required <code>model</code> <code>ElasticModel</code> <p>The elastic model defining the material properties.</p> required <code>bcs</code> <code>BoundaryConditions</code> <p>The boundary conditions for the problem.</p> required <p>Returns:</p> Type Description <code>Function</code> <p>fem.Function: The displacement solution of the elastic problem.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the 2D assumption is unknown.</p> Source code in <code>src/gcrack/solvers.py</code> <pre><code>def solve_elastic_problem(\n    domain: Domain, model: ElasticModel, bcs: BoundaryConditions\n) -&gt; fem.Function:\n    \"\"\"Solves an elastic problem using the finite element method.\n\n    This function sets up and solves a linear elastic problem using the finite element method.\n    It defines the function space, boundary conditions, and variational formulation based on the elastic energy and external work.\n    The problem is solved using PETSc's LinearProblem.\n\n    Args:\n        domain (Domain): The domain object representing the physical space.\n        model (ElasticModel): The elastic model defining the material properties.\n        bcs (BoundaryConditions): The boundary conditions for the problem.\n\n    Returns:\n        fem.Function: The displacement solution of the elastic problem.\n\n    Raises:\n        ValueError: If the 2D assumption is unknown.\n    \"\"\"\n    # Define the displacement function space\n    if model.assumption.startswith(\"plane\"):\n        shape_u = (2,)\n    elif model.assumption in [\"anti_plane\"]:\n        shape_u = (1,)\n    else:\n        raise ValueError(f\"Unknown 2D assumption: {model.assumption}.\")\n    V_u = fem.functionspace(domain.mesh, (\"Lagrange\", 1, shape_u))\n    # Define the displacement field\n    u = fem.Function(V_u, name=\"Displacement\")\n    # Define the boundary conditions\n    dirichlet_bcs = get_dirichlet_boundary_conditions(domain, V_u, bcs)\n    # Define the total energy\n    energy = model.elastic_energy(u, domain)\n    external_work = compute_external_work(domain, u, bcs)\n    if external_work:\n        energy -= external_work\n    # Derive the energy to obtain the variational formulation\n    E_u = ufl.derivative(energy, u, ufl.TestFunction(V_u))\n    E_du = ufl.replace(E_u, {u: ufl.TrialFunction(V_u)})\n    # Define the variational formulation\n    a = ufl.lhs(E_du)\n    L = ufl.rhs(E_du)\n\n    #  Define and solve the problem\n    problem = LinearProblem(\n        a,\n        L,\n        bcs=dirichlet_bcs,\n        # petsc_options={\n        #     \"ksp_type\": \"cg\",\n        #     \"ksp_rtol\": 1e-12,\n        #     \"ksp_atol\": 1e-12,\n        #     \"ksp_max_it\": 1000,\n        #     \"pc_type\": \"gamg\",\n        #     \"pc_gamg_agg_nsmooths\": 1,\n        #     \"pc_gamg_esteig_ksp_type\": \"cg\",\n        # },\n        petsc_options_prefix=\"basic_linear_problem\",\n        petsc_options={\n            \"ksp_type\": \"preonly\",\n            \"pc_type\": \"cholesky\",\n            \"pc_factor_mat_solver_type\": \"cholmod\",\n        },\n    )\n    return problem.solve()\n</code></pre>"},{"location":"API/utils/expression_parsers/","title":"Expression parsers","text":"<p>Module for parsing mathematical expressions into finite element functions.</p> <p>This module provides a utility function to parse string expressions or numerical values into finite element functions. It supports both symbolic expressions (as strings) and numerical values, converting them into appropriate FEniCSx finite element functions.</p> <p>Functions:</p> Name Description <code>parse_expression</code> <p>Parses a value into a finite element function.</p>"},{"location":"API/utils/expression_parsers/#gcrack.utils.expression_parsers.parse_expression","title":"<code>parse_expression(value, space, export_func=False)</code>","text":"<p>Parses a value into a finite element function.</p> <p>This function converts a string expression or numerical value into a finite element function. If the input is a string, it is parsed as a symbolic expression and interpolated onto the provided function space. If the input is a numerical value, it is used to create a constant finite element function. If the input is NaN, the function returns None.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The value to parse. Can be a string expression (e.g., \"x**2 + 1\") or a numerical value. If NaN, the function returns None.</p> required <code>space</code> <code>FunctionSpace</code> <p>The finite element function space onto which the expression or value should be interpolated.</p> required <code>export_func</code> <code>bool</code> <p>Flag indicating if the parameter function must be exported.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>func</code> <code>Function or None</code> <p>A finite element function representing the parsed expression or value. Returns None if the input value is NaN.</p> <p>Example:</p> <pre><code>from dolfinx import fem\nfrom gcrack.utils.expression_parsers import parse_expression\nmesh = ...  # Create a mesh\nV = fem.functionspace(mesh, (\"Lagrange\", 1))\n# Parse a string expression\nf1 = parse_expression(\"x**2 + 1\", V)\n# Parse a numerical value\nf2 = parse_expression(5.0, V)\n</code></pre> Source code in <code>src/gcrack/utils/expression_parsers.py</code> <pre><code>def parse_expression(value, space: fem.FunctionSpace, export_func: bool = False):\n    \"\"\"Parses a value into a finite element function.\n\n    This function converts a string expression or numerical value into a finite element function.\n    If the input is a string, it is parsed as a symbolic expression and interpolated onto the provided function space.\n    If the input is a numerical value, it is used to create a constant finite element function.\n    If the input is NaN, the function returns None.\n\n    Args:\n        value:\n            The value to parse.\n            Can be a string expression (e.g., \"x**2 + 1\") or a numerical value.\n            If NaN, the function returns None.\n        space (fem.FunctionSpace):\n            The finite element function space onto which the expression or value should be interpolated.\n        export_func (bool):\n            Flag indicating if the parameter function must be exported.\n\n\n    Returns:\n        func (fem.Function or None):\n            A finite element function representing the parsed expression or value.\n            Returns None if the input value is NaN.\n\n    Example:\n\n        from dolfinx import fem\n        from gcrack.utils.expression_parsers import parse_expression\n        mesh = ...  # Create a mesh\n        V = fem.functionspace(mesh, (\"Lagrange\", 1))\n        # Parse a string expression\n        f1 = parse_expression(\"x**2 + 1\", V)\n        # Parse a numerical value\n        f2 = parse_expression(5.0, V)\n    \"\"\"\n    if isinstance(value, (int, float)):\n        # Check if the DOF is imposed\n        if isnan(value):\n            return None\n        # Define an FEM function (to control the BC)\n        func = fem.Function(space)\n        # Update the load\n        with func.x.petsc_vec.localForm() as local_func:\n            local_func.set(value)\n        # Create the par_func if necessary\n        if export_func:\n\n            def par_func(xx):\n                return value\n    elif isinstance(value, str):\n        # Parse the function\n        x = sp.Symbol(\"x\")\n        # Parse the expression using sympy\n        par_func = sp.utilities.lambdify(x, value, \"numpy\")\n        # Create and interpolate the fem function\n        func = fem.Function(space)\n        func.interpolate(lambda xx: par_func(xx))\n    else:\n        raise ValueError(\"Unknown type passed to a parsed expression.\")\n\n    if not export_func:\n        return func\n    else:\n        return func, par_func\n</code></pre>"},{"location":"API/utils/geometry/","title":"Geometry","text":"<p>Module for geometric calculations in 2D and 3D spaces.</p> <p>This module provides utility functions for geometric calculations. It include the computation of distances between points and line segments in 2D and 3D spaces. It is used to remove the crack from the pacman region in SIF estimation.</p> <p>Functions:</p> Name Description <code>distance_point_to_segment</code> <p>Computes the distance between points and a line segment.</p>"},{"location":"API/utils/geometry/#gcrack.utils.geometry.distance_point_to_segment","title":"<code>distance_point_to_segment(P, A, B)</code>","text":"<p>Computes the distance between points and a line segment in 2D or 3D space.</p> <p>This function calculates the shortest distance from each point in array P to the line segment defined by endpoints A and B.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>ndarray</code> <p>Array of shape (n, m) where n is the number of points and m is the number of dimensions (2 or 3). Each row represents a point.</p> required <code>A</code> <code>ndarray</code> <p>1D array of shape (m,) representing one endpoint of the segment.</p> required <code>B</code> <code>ndarray</code> <p>1D array of shape (m,) representing the other endpoint of the segment.</p> required <p>Returns:</p> Name Type Description <code>distance</code> <code>ndarray</code> <p>Array of shape (n,) where each element is the distance from the corresponding point in P to the segment AB.</p> Source code in <code>src/gcrack/utils/geometry.py</code> <pre><code>def distance_point_to_segment(\n    P: np.ndarray, A: np.ndarray, B: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Computes the distance between points and a line segment in 2D or 3D space.\n\n    This function calculates the shortest distance from each point in array P to the line segment defined by endpoints A and B.\n\n    Args:\n        P (np.ndarray):\n            Array of shape (n, m) where n is the number of points and m is the number of dimensions (2 or 3).\n            Each row represents a point.\n        A (np.ndarray):\n            1D array of shape (m,) representing one endpoint of the segment.\n        B (np.ndarray):\n            1D array of shape (m,) representing the other endpoint of the segment.\n\n    Returns:\n        distance (np.ndarray):\n            Array of shape (n,) where each element is the distance from the corresponding point in P to the segment AB.\n    \"\"\"\n    # Ensure A and B are 2D for broadcasting with P\n    A = A[:, np.newaxis] if A.ndim == 1 else A\n    B = B[:, np.newaxis] if B.ndim == 1 else B\n\n    # Vector AB\n    AB = B - A\n\n    # Vector AP for each point P\n    AP = P - A\n\n    # Project vector AP onto AB to find the projection point on the line (may lie outside the segment)\n    AB_squared = np.sum(AB**2, axis=0)\n    if np.all(AB_squared == 0):  # A and B are the same point\n        return np.linalg.norm(AP, axis=0)\n\n    t = np.clip(np.sum(AP * AB, axis=0) / AB_squared, 0, 1)\n\n    # The projection point on the segment\n    projection = A + t * AB\n\n    # Distance from point P to the projection point\n    distance = np.linalg.norm(P - projection, axis=0)\n\n    return distance\n</code></pre>"},{"location":"API/utils/williams_series/","title":"Williams series","text":"<p>Module for computing Williams series functions for crack tip fields.</p> <p>This module provides functions to compute the Williams series functions (Gamma_I, Gamma_II, Gamma_III) for crack tip displacement fields in linear elastic fracture mechanics. These functions are used to represent the displacement fields around a crack tip using complex variable methods.</p> <p>Functions:</p> Name Description <code>Gamma_I</code> <p>Computes the Williams series function for mode I.</p> <code>Gamma_II</code> <p>Computes the Williams series function for mode II.</p> <code>Gamma_III</code> <p>Computes the Williams series function for mode III.</p>"},{"location":"API/utils/williams_series/#gcrack.utils.williams_series.Gamma_I","title":"<code>Gamma_I(n, z, mu, ka)</code>","text":"<p>Computes the Williams series function for mode I crack tip displacement fields.</p> <p>This function calculates the function for the mode I (opening mode) term in the Williams series expansion of the displacement field around a crack tip. The function is expressed in terms of complex coordinates and material properties.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The order of the term in the Williams series expansion.</p> required <code>z</code> <code>complex</code> <p>Complex coordinate relative to the crack tip.</p> required <code>mu</code> <code>float</code> <p>Shear modulus of the material.</p> required <code>ka</code> <code>float</code> <p>Kolosov constant, which depends on the material properties and the 2D assumption.</p> required <p>Returns:</p> Name Type Description <code>complex</code> <p>The Williams series function for mode I at the given point.</p> Notes <ul> <li>The function uses polar coordinates derived from the complex coordinate z.</li> <li>The result is a complex number representing the function in the series expansion.</li> <li>The function is JIT-compiled using JAX for efficient execution.</li> </ul> Source code in <code>src/gcrack/utils/williams_series.py</code> <pre><code>@jax.jit\ndef Gamma_I(n: int, z: complex, mu: float, ka: float):\n    \"\"\"Computes the Williams series function for mode I crack tip displacement fields.\n\n    This function calculates the function for the mode I (opening mode) term in the Williams series expansion of the displacement field around a crack tip.\n    The function is expressed in terms of complex coordinates and material properties.\n\n    Args:\n        n (int): The order of the term in the Williams series expansion.\n        z (complex): Complex coordinate relative to the crack tip.\n        mu (float): Shear modulus of the material.\n        ka (float): Kolosov constant, which depends on the material properties and the 2D assumption.\n\n    Returns:\n        complex: The Williams series function for mode I at the given point.\n\n    Notes:\n        - The function uses polar coordinates derived from the complex coordinate z.\n        - The result is a complex number representing the function in the series expansion.\n        - The function is JIT-compiled using JAX for efficient execution.\n    \"\"\"\n    # Compute the polar coordinates\n    r = jnp.abs(z)\n    theta = jnp.angle(z)\n    # Compute the factor\n    return (\n        r ** (n / 2)\n        / (2 * mu * jnp.sqrt(2 * jnp.pi))\n        * (\n            ka * jnp.exp(1j * theta * n / 2)\n            - n / 2 * jnp.exp(1j * theta * (4 - n) / 2)\n            + (n / 2 + (-1) ** n) * jnp.exp(-1j * n * theta / 2)\n        )\n    )\n</code></pre>"},{"location":"API/utils/williams_series/#gcrack.utils.williams_series.Gamma_II","title":"<code>Gamma_II(n, z, mu, ka)</code>","text":"<p>Computes the Williams series function for mode II crack tip displacement fields.</p> <p>This function calculates the function for the mode II (opening mode) term in the Williams series expansion of the displacement field around a crack tip. The function is expressed in terms of complex coordinates and material properties.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The order of the term in the Williams series expansion.</p> required <code>z</code> <code>complex</code> <p>Complex coordinate relative to the crack tip.</p> required <code>mu</code> <code>float</code> <p>Shear modulus of the material.</p> required <code>ka</code> <code>float</code> <p>Kolosov constant, which depends on the material properties and the 2D assumption.</p> required <p>Returns:</p> Name Type Description <code>complex</code> <p>The Williams series function for mode II at the given point.</p> Notes <ul> <li>The function uses polar coordinates derived from the complex coordinate z.</li> <li>The result is a complex number representing the function in the series expansion.</li> <li>The function includes a negative sign to recover the classic mode II displacement field.</li> <li>The function is JIT-compiled using JAX for efficient execution.</li> </ul> Source code in <code>src/gcrack/utils/williams_series.py</code> <pre><code>@jax.jit\ndef Gamma_II(n: int, z: complex, mu: float, ka: float):\n    \"\"\"Computes the Williams series function for mode II crack tip displacement fields.\n\n    This function calculates the function for the mode II (opening mode) term in the Williams series expansion of the displacement field around a crack tip.\n    The function is expressed in terms of complex coordinates and material properties.\n\n    Args:\n        n (int): The order of the term in the Williams series expansion.\n        z (complex): Complex coordinate relative to the crack tip.\n        mu (float): Shear modulus of the material.\n        ka (float): Kolosov constant, which depends on the material properties and the 2D assumption.\n\n    Returns:\n        complex: The Williams series function for mode II at the given point.\n\n    Notes:\n        - The function uses polar coordinates derived from the complex coordinate z.\n        - The result is a complex number representing the function in the series expansion.\n        - The function includes a negative sign to recover the classic mode II displacement field.\n        - The function is JIT-compiled using JAX for efficient execution.\n    \"\"\"\n    # Compute the polar coordinates\n    r = jnp.abs(z)\n    theta = jnp.angle(z)\n    # Compute the factor\n    # NOTE: Minus sign to recover the classic mode II (+ux above the crack and -ux below the crack)\n    return (\n        -1j\n        * r ** (n / 2)\n        / (2 * mu * jnp.sqrt(2 * jnp.pi))\n        * (\n            ka * jnp.exp(1j * theta * n / 2)\n            + n / 2 * jnp.exp(1j * theta * (4 - n) / 2)\n            - (n / 2 - (-1) ** n) * jnp.exp(-1j * n * theta / 2)\n        )\n    )\n</code></pre>"},{"location":"API/utils/williams_series/#gcrack.utils.williams_series.Gamma_III","title":"<code>Gamma_III(n, z, mu, ka)</code>","text":"<p>Computes the Williams series function for mode III crack tip displacement fields.</p> <p>This function calculates the function for the mode III (opening mode) term in the Williams series expansion of the displacement field around a crack tip. The function is expressed in terms of complex coordinates and material properties.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The order of the term in the Williams series expansion.</p> required <code>z</code> <code>complex</code> <p>Complex coordinate relative to the crack tip.</p> required <code>mu</code> <code>float</code> <p>Shear modulus of the material.</p> required <code>ka</code> <code>float</code> <p>Kolosov constant, which depends on the material properties and the 2D assumption.</p> required <p>Returns:</p> Name Type Description <code>complex</code> <p>The Williams series function for mode III at the given point.</p> Notes <ul> <li>The function uses polar coordinates derived from the complex coordinate z.</li> <li>The result is a complex number representing the function in the series expansion.</li> <li>The function is JIT-compiled using JAX for efficient execution.</li> <li>The ka parameter is included for consistency with the other modes but is not used in the calculation.</li> </ul> Source code in <code>src/gcrack/utils/williams_series.py</code> <pre><code>@jax.jit\ndef Gamma_III(n: int, z: complex, mu: float, ka: float):\n    \"\"\"Computes the Williams series function for mode III crack tip displacement fields.\n\n    This function calculates the function for the mode III (opening mode) term in the Williams series expansion of the displacement field around a crack tip.\n    The function is expressed in terms of complex coordinates and material properties.\n\n    Args:\n        n (int): The order of the term in the Williams series expansion.\n        z (complex): Complex coordinate relative to the crack tip.\n        mu (float): Shear modulus of the material.\n        ka (float): Kolosov constant, which depends on the material properties and the 2D assumption.\n\n    Returns:\n        complex: The Williams series function for mode III at the given point.\n\n    Notes:\n        - The function uses polar coordinates derived from the complex coordinate z.\n        - The result is a complex number representing the function in the series expansion.\n        - The function is JIT-compiled using JAX for efficient execution.\n        - The ka parameter is included for consistency with the other modes but is not used in the calculation.\n    \"\"\"\n    # Compute the polar coordinates\n    r = jnp.abs(z)\n    theta = jnp.angle(z)\n    # Compute the factor\n    return (\n        r ** (n / 2)\n        / (2 * mu * jnp.sqrt(2 * jnp.pi))\n        * jnp.sin(n / 2 * theta + (1 + (-1) ** n) / 2 * jnp.pi / 2)\n    )\n</code></pre>"}]}